[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Manuel de protection des tableaux",
    "section": "",
    "text": "Introduction\nLe Manuel de protection des tableaux vise à accompagner les équipes en charge de la protection des données tabulées à l’Insee et au sein du SSP en général. Ce manuel fournit un première réponse à la recommandation de la mission de l’inspection générale sur la diffusion sur mesure, dont le rapport est consultable ici.\nCe manuel, rédigé par la section Méthodes statistiques spatiales et secret statistique au sein du DMS, a vocation à présenter les principales notions à connaître, à proposer une démarche méthodologique pour analyser tout type de demande et à illustrer avec de nombreux exemples comment, en pratique, il est possible de protéger un ensemble de tableaux avant leur diffusion.\nCe manuel a pour principaux objectifs d’harmoniser les pratiques au sein de l’institut et du SSP et de proposer une documentation aussi complète et pratique pour les utilisateurs que possible.\nCe manuel s’adresse à toute personne en charge de diffuser des données tabulées auprès du public, en particulier les chargés de réponse à la demande à la DG, dans les pôles ou en DR, ainsi que les producteurs désireux de publier leurs données sur insee.fr, dans un Insee Références, un Insee Résultats ou toute autre publication.\nLes notions principales utiles pour la pose du secret sont présentées au Chapitre 1. L’idée est de se baser sur un vocabulaire commun afin d’être sûrs de parler de la même chose.\nLa démarche pour poser le secret sur un tableau est présentée au Chapitre ?sec-secretuntableau.\nComme une diffusion concerne le plus souvent plusieurs tableaux, la démarche pour analyser de telles demandes est présentée au Chapitre 3. Cette étape consiste, à partir de la liste de tableaux à diffuser, à déterminer la liste de tableaux qu’il faut protéger, en étudiant, notamment, les liens existants entre ces tableaux.\nLorsque l’on traite plusieurs tableaux simultanément il faut bien prendre en compte l’existence de mêmes croisements entre les tableaux. C’est ce qui est fait dans le Chapitre ?sec-secrettableauxlies qui présente la pose du secret sur des tableaux liés.\nLe Chapitre ?sec-fichespratiques regroupe plusieurs cas particuliers pour poser le secret à l’aide de rtauargus. Les fiches sont de niveau croissant, allant de débutant à expert, et devraient permettre, à terme, d’accompagner les utilisateurs dans la plupart des situations rencontrées en pratique.\nEnfin le Chapitre ?sec-presentationoutils fournit des informations complémentaires sur \\(\\tau\\)-Argus et sur le package rtauargus. L’utilisateur y trouvera en particulier une description des différents types de fichiers créés par le package et utiles à \\(\\tau\\)-Argus, ainsi que des éléments pour comprendre et résoudre certaines erreurs provenant du logiciel.\nLes annexes contiennent un rappel de certaines règles du secret en vigueur (Chapitre 11) et un petit tutoriel sur la manipulation des listes pour celles et ceux qui ne seraient pas familiers avec ce type d’objets R très utiles (Chapitre 12)."
  },
  {
    "objectID": "01_notions.html",
    "href": "01_notions.html",
    "title": "1  Notions principales à connaître",
    "section": "",
    "text": "1.1 Comment décrire un tableau ?\nUn tableau présente le résultat de l’agrégation d’un indicateur connu au niveau individuel, ventilé selon une ou plusieurs catégories de ces individus.\nOn appellera :\nExemples de tableaux :\nIl existe 3 formats de tableaux :\nEn général, un utilisateur final pense à un tableau croisé. Mais pour la pose du secret, on travaillera exclusivement avec la forme longue des tableaux. Un tableau long est donc composé de deux types de variables :",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notions principales à connaître</span>"
    ]
  },
  {
    "objectID": "01_notions.html#comment-décrire-un-tableau",
    "href": "01_notions.html#comment-décrire-un-tableau",
    "title": "1  Notions principales à connaître",
    "section": "1.1 Comment décrire un tableau ?",
    "text": "1.1 Comment décrire un tableau ?\nUn tableau présente le résultat de l’agrégation d’un indicateur connu au niveau individuel, ventilé selon une ou plusieurs catégories de ces individus.\nOn appellera :\n\nIndicateur ou variable réponse, la variable numérique agrégée. En général on précise également l’opération d’agrégation utilisée. Par exemple, le nombre d’entreprises (somme de pondérations dans le cas d’une enquête, sinon simple comptage), le chiffre d’affaire (sous-entendu le total ou la somme des chiffres d’affaire), la moyenne d’âge, la part de personnes vivant sous le seuil de pauvreté, etc.\nVariable(s) de croisement ou variable(s) explicatives, la ou les variables de ventilation de l’indicateur. Ce sont des variables dites catégorielles (ex : diplôme, le secteur d’activité) et sont parfois des variables numériques découpées en tranches (ex : classes d’âge, tranches d’effectifs).\nChamp, la population ou sous-population sur laquelle l’agrégation est réalisée. Par exemple, un tableau restreint à la population des 15-25 ans ou aux entreprises du secteur de l’industrie.\n\n\n\n\nLe nombre d’entreprises selon leur région d’implantation et le caractère polluant de leurs activités, parmi les entreprises du secteur industriel\n\n\nExemples de tableaux :\n\nOn veut diffuser la moyenne d’âge des chefs d’entreprises par secteur d’activité :\n\nvariable de croisement : secteur d’activité (ACT)\nindicateur : âge moyen (x_age)\nchamp : toutes entreprises confondues\n\nOn souhaite diffuser la note moyenne au brevet des élèves entrant en seconde selon la région, le secteur de l’établissement (public, privé), et la catégorie socio-professionnelle des parents :\n\nvariable de croisement : région (REG), secteur (SEC)\nindicateur : note moyenne (x_note)\nchamp : élèves de seconde de l’année N\n\n\nIl existe 3 formats de tableaux :\n\nLes tableaux croisés, particulièrement adaptés à la diffusion d’une information ventilée selon deux variables catégorielles (cf.  Tableau croisé).\nLes tableaux longs, particulièrement adaptés aux traitements des données, et résultats naturels des agrégations réalisées en R avec dplyr (group_by() + summarise()) aussi bien qu’avec data.table (melt()).\nLes tableaux larges, autre format parfois utile lors des traitements, sont tels que chaque croisement de modalités des variables catégorielles est une variable du tableau.\n\n\n\n\nTableau long formé à partir du tableau croisé précédent\n\n\n\n\n\nTableau large formé à partir du tableau croisé précédent\n\n\nEn général, un utilisateur final pense à un tableau croisé. Mais pour la pose du secret, on travaillera exclusivement avec la forme longue des tableaux. Un tableau long est donc composé de deux types de variables :\n\nLes variables de croisements (catégorielles) qui servent à décrire le contexte d’une cellule ;\nLa variable réponse (ou indicateur) qui indique la valeur d’une cellule."
  },
  {
    "objectID": "01_notions.html#tableaux-deffectifs-et-tableaux-de-magnitude",
    "href": "01_notions.html#tableaux-deffectifs-et-tableaux-de-magnitude",
    "title": "1  Notions principales à connaître",
    "section": "1.2 Tableaux d’effectifs et tableaux de magnitude",
    "text": "1.2 Tableaux d’effectifs et tableaux de magnitude\nOn distingue deux types de tableaux : les tableaux d’effectifs et ceux de magnitude.\nUn tableau d’effectifs est un tableau dans lequel la valeur d’une cellule correspond au nombre d’unités qui partagent les caractéristiques de la cellule.\nVoici un exemple de tableau d’effectifs :\n\n\n\nNombre d’entreprises polluantes par région\n\n\nUn tableau de magnitude (ou de volume) est un tableau dans lequel la valeur de chaque cellule représente la somme des contributions des répondants qui partagent les caractéristiques de cette cellule.\nVoici un exemple de tableau de magnitude :\n\n\n\nVentes réalisées, en millions d’euros (nombre de contributeurs)"
  },
  {
    "objectID": "01_notions.html#secret-primaire-et-secret-secondaire",
    "href": "01_notions.html#secret-primaire-et-secret-secondaire",
    "title": "1  Notions principales à connaître",
    "section": "1.3 Secret primaire et secret secondaire",
    "text": "1.3 Secret primaire et secret secondaire\nLe secret primaire renvoie aux cellules qui doivent être secretisées dès le départ du processus de secrétisation car elles sont considérées comme sensibles (ou confidentielles) d’après des règles définies à l’Insee.\n\nRègle de fréquence : une cellule d’un tableau ne doit pas être construite à partir de strictement moins de 3 unités.\nRègle de dominance : une unité contributrice à une cellule ne peut contribuer à plus de 85% de la valeur de celle-ci. Afin, de pouvoir appliquer cette règle il faut donc déterminer pour chaque cellule du tableau le plus gros contributeur.\n\nN.B. pour les bases de données pondérées :\n\nOn applique la règle de fréquence sur les pondérations. Si une cellule est construite par 2 répondants mais en représente davantage, alors elle est diffusable. Il faut veiller à ce que l’échantillon et la pondération restent confidentiels.\nD’après la règle de dominance, la cellule est sensible si le contributeur maximal (non pondérée) est supérieur à 85% du total de la cellule (pondéré).\n\nSelon le type de données les règles peuvent varier ainsi les cellules considérées comme sensibles varient elles aussi. Par exemple, pour les statistiques d’entreprises les cellules sont catégorisées comme sensibles du fait de la règle de fréquence (moins de 3 unités dans une cellule) ou de la règle de dominance (un répondant représente plus de 85% du total de la cellule). On ne peut pas diffuser les cellules qui constituent le secret primaire. Pour plus d’informations sur les règles du secret voir l’Annexe.\nUne solution pour ne pas diffuser ces cellules est de les supprimer (cacher). Cependant, uniquement supprimer les cellules touchées par le secret primaire n’est généralement pas suffisant. En effet, si les marges du tableau sont diffusées, alors les cellules sont liées entre elles par des équations. Ainsi, il faut cacher d’autres cellules pour ne pas pouvoir déduire la valeur des cellules cachées : c’est le secret secondaire."
  },
  {
    "objectID": "01_notions.html#sec-hrc",
    "href": "01_notions.html#sec-hrc",
    "title": "1  Notions principales à connaître",
    "section": "1.4 Variable hiérarchique",
    "text": "1.4 Variable hiérarchique\nUne variable hiérarchique est une variable de ventilation comprenant plusieurs sous-totaux. Autrement dit, certaines modalités de cette variables se somment en une autre modalité de la variable.\nPar exemple, on pourrait imaginer une variable hiérarchique géographique comme dans le tableau suivant :\n\n\n\nNombre d’entreprises qui produisent des violons, par région\n\n\nOn peut aussi la représenter sous forme d’arbre :\n\n\n\n\nflowchart TD\n  A[Pays] --&gt; B[Nord]\n  A[Pays] --&gt; C[Ouest]\n  A[Pays] --&gt; D[Est]\n  A[Pays] --&gt; E[Sud]\n  B --&gt; F[N1]\n  B --&gt; G[N2]\n  B --&gt; H[N3]\n  C --&gt; I[O1]\n  C --&gt; J[O2]\n  C --&gt; K[O3]\n  C --&gt; L[04]\n  D --&gt; M[E1]\n  D --&gt; N[E2]\n  D --&gt; O[E3]\n  E --&gt; P[S1]\n  E --&gt; Q[S2]"
  },
  {
    "objectID": "01_notions.html#sec-hrcnonemb",
    "href": "01_notions.html#sec-hrcnonemb",
    "title": "1  Notions principales à connaître",
    "section": "1.5 Hiérarchies non-emboîtées",
    "text": "1.5 Hiérarchies non-emboîtées\nUne hiérarchie non-emboîtée est le cas où dans un tableau diffusé, l’emboîtement des modalités d’une variable hiérarchique n’est pas parfait.\nPar exemple si on utilise une variable de la NAF A88 comme suit et que l’on veut aussi diffuser un sous-total regroupant les codes division 03, 05 et 06 alors on a une hiérarchie non-emboîtée.\n\n\n\nExemple hiérarchie non-emboîtée à partir de la NAF A88"
  },
  {
    "objectID": "01_notions.html#liaisons-entre-tableaux",
    "href": "01_notions.html#liaisons-entre-tableaux",
    "title": "1  Notions principales à connaître",
    "section": "1.6 Liaisons entre tableaux",
    "text": "1.6 Liaisons entre tableaux\nOn dit que des tableaux sont liés lorsqu’ils possèdent la même variable ventilée et partagent une ou plusieurs variables de ventilation. Ces liens entre tableaux doivent être pris en compte pour traiter correctement le secret. Sinon, les cellules cachées peuvent se déduire les unes des autres.\nLes liens les plus courants sont :\n\nLes tableaux partageant des marges communes (i.e. partageant le même champ, la même variable de réponse, une ou plusieurs variables de croisement);\nLes tableaux additifs ou corrélés (i.e. partageant le même champ, les mêmes variables de croisements, les variables de réponse différentes mais liées entre elles - équation ou corrélation);\nLes hiérarchies non-emboîtées ;\nLes différences de millésime.\n\nEn effet, pour des données périodiques, la temporalité peut être perçue comme un ensemble de tableaux liés : il vaut mieux que le masque de secret change peu entre chaque millésime.\nPar exemple si l’on souhaite diffuser le nombre d’entreprises en France selon :\n\nT0_1: le sexe de son/sa dirigeant(e) et la région d’implantation\nT0_2: le sexe de son/sa dirigeant(e) et la caractère polluant ou non de l’activité d’entreprise\nT0_3: le caractère polluant ou non de l’activité de l’entreprise et la région d’implantation\n\nNombre d’entreprises par région et par sexe du dirigeant (T0_1)\n\n\n\n\nFemme\nHomme\nTotal\n\n\n\n\nNord\n16\n20\n36\n\n\nSud\n19\n12\n31\n\n\nTotal\n35\n32\n67\n\n\n\nNombre d’entreprises polluantes par sexe du dirigeant (T0_2)\n\n\n\n\nPolluante\nNon polluante\nTotal\n\n\n\n\nFemme\n8\n27\n35\n\n\nHomme\n22\n17\n32\n\n\nTotal\n30\n37\n67\n\n\n\nNombre d’entreprises polluantes par région (T0_3)\n\n\n\n\nPolluante\nNon polluante\nTotal\n\n\n\n\nNord\n10\n26\n36\n\n\nSud\n20\n11\n31\n\n\nTotal\n30\n37\n67\n\n\n\nCes trois tableaux sont liés puisqu’ils partagent des marges communes :\n\nT0_1 et T0_2 ont les mêmes marges sur la variable SEXE\nT0_1 et T0_3 ont les mêmes marges sur la variable REGION\nT0_2 et T0_3 ont les mêmes marges sur la variable POLL"
  },
  {
    "objectID": "01_notions.html#tableau-à-diffuser-vs-à-protéger",
    "href": "01_notions.html#tableau-à-diffuser-vs-à-protéger",
    "title": "1  Notions principales à connaître",
    "section": "1.7 Tableau à diffuser vs à protéger",
    "text": "1.7 Tableau à diffuser vs à protéger\nLa pose du secret nécessite de bien identifier les tableaux liés entre eux et les hiérarchies (emboîtées ou non). En fonction des liens identifiés, l’ensemble des tableaux à diffuser sera soit scindé (absence de relations) ou au contraire considéré d’un seul tenant (équations entre variables). Cette phase d’analyse de la demande, développée au Chapitre 3 va permettre de construire les tableaux à protéger, lesquels sont le plus souvent distincts des tableaux qui seront effectivement diffusés."
  },
  {
    "objectID": "02_secret_un_tableau.html",
    "href": "02_secret_un_tableau.html",
    "title": "2  Poser le secret sur un tableau",
    "section": "",
    "text": "Etapes de la pose du secret sur un seul tableau\n\n\n\n\nPoser le secret primaire\nCalculer le nombre de cellules détectées comme à risque\nPoser le secret secondaire à l’aide de la fonction tab_rtauargus()\nFaire une synthèse du secret posé\n\n\n\nCe chapitre a été réalisé avec la version 1.2.0 de rtauargus et la version 4.2.3 de TauArgus.\n\nlibrary(rtauargus)\nlibrary(dplyr)\n\nPoser un masque de secret sur un tableau comprend les étapes suivantes :\n\nPoser le secret primaire en créant des variables indicatrices :\n\n\nPour chacun des tableaux on ajoute une variable booléenne indiquant si la cellule est problématique (TRUE) ou non (FALSE), au regarde des règles pertinentes à appliquer comme : la règle de fréquence is_secret_freq ou la règle de dominance is_secret_dom\nEnsuite, on crée une variable résumant le secret primaire is_secret_prim :\n\nis_secret_prim = is_secret_freq si seule la règle de fréquence doit s’appliquer\nis_secret_prim = is_secret_freq | is_secret_dom si les deux règles doivent s’appliquer\n\n\nVoici un exemple de code pour les règles classiques en statistiques d’entreprises :\nLe tableau T0 présente le chiffre d’affaires des entreprises ventilé par leur activité et leur taille.\n\nstr(T0)\n\ntibble [414 × 5] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY: chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE    : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ    : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE   : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX     : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n\n# Pose du secret \"manuelle\"\nT0_detect &lt;- T0 %&gt;% \n  mutate(\n      is_secret_freq = FREQ &gt; 0 & FREQ &lt; 3,\n      is_secret_dom = (VALUE != 0) & (MAX &gt; 0.85*VALUE)\n    ) %&gt;% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\n# Résultat\nstr(T0_detect)\n\ntibble [414 × 8] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE          : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ          : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE         : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX           : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n $ is_secret_freq: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n\n\n\nCalculer le nombre de cellules détectées comme à risque\nPoser le secret secondaire en utilisant le package rtauargus en utilisant la fonction tab_rtauargus().\n\nLa fonction tab_rtauargus() requiert les arguments suivants :\n\ntabular: la table à protéger\ndir_name: le nom du répertoire où les fichiers seront sauvegardés\nfiles_name: le nom utilisé pour nommer les fichiers (chaque fichier a une extension différente);\nexplanatory_vars: le nom des variables de croisements présents dans la table;\nsecret_var: le nom de la variable indiquant si une cellule est à risque ou non (secret primaire);\nvalue = nom de la variable de réponse;\nfreq = nom de la variable d’effectifs;\ntotcode: le code utilisé pour indiquer le total pour chacune des variables de croisements (explanatory_vars).\n\n\n# Localisation de tauargus sur AUS\nloc_tauargus &lt;- \"Y:/Logiciels/TauArgus/TauArgus4.2.3/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n\n# Préciser la localisation de tauargus\nloc_tauargus &lt;- \"C:/Users/tmm7an/Documents/SDC/TauArgus/TauArgus4.2.3/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n\n\nT0_masq &lt;- tab_rtauargus(\n  T0_detect,\n  dir_name = \"tauargus_files/ex_T0\",\n  files_name = \"T0\",\n  explanatory_vars = c(\"ACTIVITY\",\"SIZE\"),\n  secret_var = \"is_secret_prim\",\n  value = \"VALUE\",\n  freq = \"FREQ\",\n  totcode = c(ACTIVITY=\"Total\",SIZE=\"Total\"),\n  verbose = FALSE\n)\n\n\nCalculer le nombre de cellules selon leur statut final en suivant la norme européenne :\n\n\nA les cellules en secret primaire à cause de la règle de fréquence\nB les cellules en secret primaire à cause de la règle de dominance (dans le futur ces cellules pourraient être notées O)\nD les cellules concernées par le secret secondaire\nV les cellules non touchées par le secret, c’est-à-dire les cellules qui pourront être diffusées.\n\nPour faire le bilan du secret, le mieux est de modifier la variable Status fournie par Tau-Argus. En effet, cette variable ne permet pas de faire la distinction entre les deux types de secret primaire (fréquence ou dominance), on modifie donc ces modalités pour faire apparaître cette distinction.\n\nT0_masq &lt;- T0_masq %&gt;% \n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  )\n\nAfin de bien appréhender l’impact du secret posé, on va non seulement compter le nombre de cellules masquées, mais aussi calculer la valeur des cellules masquées.\n\nT0_masq %&gt;% \n  group_by(statut_final) %&gt;% \n  summarise(\n    n_cell = n(),\n    val_cell = sum(VALUE)\n  ) %&gt;%\n  mutate(\n    pc_n_cell = n_cell/sum(n_cell)*100,\n    pc_val_cell = val_cell/sum(val_cell)*100\n  )\n\n# A tibble: 4 × 5\n  statut_final n_cell    val_cell pc_n_cell pc_val_cell\n  &lt;chr&gt;         &lt;int&gt;       &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 A                52   22115262.     12.6         1.51\n2 B                25   37823909.      6.04        2.59\n3 D                46   21032941.     11.1         1.44\n4 V               291 1381270369.     70.3        94.5 \n\n\nUn bon indicateur de la qualité du secret secondaire posé consiste à rapporter le nombre de cellules supprimées lors de cette phase au nombre de cellules détectées comme à risque (secret primaire). Ici par exemple, nous avons un ratio de \\(46/(52+25) = 0.6\\). Ainsi, pour protéger une case en secret primaire, Tau-argus a dû masquer 0.6 cellule(s) ; ce qui est très peu car ce ratio est généralement autour de 2.\nEn effet, pour un tableau à deux dimensions, la présence d’un secret primaire engendre la suppression d’au moins 3 cellules supplémentaires. Donc, le ratio obtenu sur cet exemple indique qu’un certain nombre de cellules en secret primaire se protègent entre elles."
  },
  {
    "objectID": "03_analyser_une_demande.html",
    "href": "03_analyser_une_demande.html",
    "title": "3  Comment analyser une demande ?",
    "section": "",
    "text": "3.1 Étapes de l’analyse de demande",
    "crumbs": [
      "La pose de secret",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comment analyser une demande ?</span>"
    ]
  },
  {
    "objectID": "03_analyser_une_demande.html#étapes-de-lanalyse-de-demande",
    "href": "03_analyser_une_demande.html#étapes-de-lanalyse-de-demande",
    "title": "3  Comment analyser une demande ?",
    "section": "3.1 Étapes de l’analyse de demande",
    "text": "3.1 Étapes de l’analyse de demande\n\n\n\n\n\n\nEtapes de l’analyse de la demande\n\n\n\n\nRéunir les informations nécessaires à la gestion de la confidentialité\nSéparer la demande en sous-demande indépendantes si possible\nDétecter les liens\nConstruire les hiérarchies éventuellement nécessaires\nLister les tableaux nécessaires pour la pose de secret (passage de la liste de diffusion à la liste de protection).\n\n\n\n\n3.1.1 Vérifier que toutes les informations nécessaires à la gestion de la confidentialité sont disponibles\nLes informations nécessaires sont :\n\nLes règles de secret qui s’appliquent sur les données (voir Annexes)\nUne description précise des tableaux que votre interlocuteur souhaite diffuser :\n\nsur quel champ de la population les tableaux sont-ils construits ?\nquelles sont les variables descriptives (de croisement) ?\nquelle est la variable de réponse pour chacun des tableaux ?\nles tableaux sont-ils des tableaux de fréquence ou bien des tableaux de volume ?\nparmi l’ensemble des variables de croisement, certaines sont-elles hiérarchiques ? Les emboîtements ont-ils été fournis ?\n\nUne description précise des liens éventuels entre les variables ou tableaux :\n\ncertaines variables ou modalités sont-elles reliées par une équation ?\ndes équations/liens ont-ils été fournis ?\nde fortes corrélations existent-elles entre certaines variables de réponse ?\n\n\n\n\n3.1.2 La demande peut-elle être séparée en plusieurs sous-demandes indépendantes ?\n\nDes tableaux portant sur des variable de réponse différentes, non liées par une équation ou par un lien de corrélation fort, peuvent être traités séparément.\nDes tableaux construits sur des champs différents et non complémentaires peuvent être traités séparément.\nY a-t-il au contraire des tableaux qui doivent être traités dans dans le même temps ?\n\nrassembler les tableaux partageant la même variable de réponse et le même champ, car ils partagent a minima le même super-total (n.b. on ne les fusionne pas on les rassemblent juste pour les traiter ensemble)\ndéterminer les tableaux liés entre eux par leurs marges\ndéterminer les tableaux liés entre eux car “additifs”\ndéterminer les tableaux liés entre eux par la présence potentielle de hiérarchies non-emboîtées\n\n\nChaque sous-demande doit faire l’objet d’un traitement à part, en suivant les mêmes étapes.\n\n\n3.1.3 Détecter les liens\nIl y a deux principaux types de liens sur les variables réponse :\n\nles hiérarchies\n\nemboîtées (voir Notions)\nnon-emboîtées (voir Notions)\n\nles équations du type A = B + C\n\nentre les variables réponses\nau niveau des champs\n\n\nEn présence de tels liens il faut parfois regrouper des tableaux en un seul (hiérarchie emboîtée sur une variable de croisement), ou au contraire construire deux tableaux à partir d’un seul (hiérarchie non-emboîtée). Dans tous les cas lorsque des tableaux sont liés il faut les traiter ensemble afin que lorsqu’une cellule est touchée dans un tableau, elle le soit aussi automatiquement dans tous les autres tableaux où elle apparaît.\n\n\n3.1.4 Passer de la liste de diffusion à la liste de protection\nLa liste de diffusion est la liste de tableaux qui sera effectivement publiée. Elle diffère de la liste de protection qui elle est à établir en fonction des liens entre les différents tableaux. En effet, pour poser le secret pertinemment il faut renseigner les différents liens pour que l’algorithme en tienne compte.\nPar exemple on peut être amené à :\n\nRassembler en un seul tableau les tableaux liés car “additifs”.\nSéparer en plusieurs tableaux un tableau qui contiendrait des sous-totaux non-emboîtés.\n\nDe plus, si les données sont sous forme de micro-données il faut calculer les agrégats qui seront diffusés pour établir la liste de diffusion. En effet, nous ne posons pas le secret sur les micro-données mais sur les agrégats. Pour ce faire la fonction tabul_fun_group permet de facilement construire les tables agrégées sous le bon format pour les mettre en entrée de rtauargus."
  },
  {
    "objectID": "03_analyser_une_demande.html#fiches-exemples-danalyse-de-demandes",
    "href": "03_analyser_une_demande.html#fiches-exemples-danalyse-de-demandes",
    "title": "3  Comment analyser une demande ?",
    "section": "3.2 Fiches exemples d’analyse de demandes",
    "text": "3.2 Fiches exemples d’analyse de demandes\n\n3.2.1 Exemple 1 : niveau facile\nDemande - on souhaite diffuser 4 tableaux\n\nT1 : population par âge (5 classes), par sexe et par département\nT2 : population par sexe, par diplôme et par département\nT3 : population par catégorie catégorie socio-professionnelle, par statut d’activité et par département\nT4 : population par âge, par sexe et par statut d’activité\n\nEn formalisant :\n\nT1 : pop \\(\\bigotimes\\) {age x sexe x dep}\nT2 : pop \\(\\bigotimes\\) {sexe x dip x dep}\nT3 : pop \\(\\bigotimes\\) {socpro x act x dep}\nT4 : pop \\(\\bigotimes\\) {age x sexe x act}\n\nAnalyse\nLes tableaux partagent le même champ (sous-entendu) et le même indicateur (population), ils sont donc liés a minima par le total, donc il n’y a pas de sous-demande indépendante.\nDe plus, certains tableaux ont des variables de croisement communes, il y a un lien sur les marges, les liens n’en sont que renforcés.\nLes variables entre elles n’ont pas de lien hiérarchique (le seul niveau géographique est le département), donc les tableaux ne doivent pas être fusionnés.\nFinalement, la liste des tableaux à protéger est identique à la liste des tableaux à diffuser.\n\n\n3.2.2 Exemple 2 : niveau moyen\nDemande - on souhaite diffuser 7 tableaux\n\nT1 : population par âge (5 classes), par sexe et par département\nT2 : population par sexe, par diplôme et par département\nT3 : population par catégorie catégorie socio-professionnelle, par statut d’activité et par département\nT4 : population par âge, par sexe et par statut d’activité\nT5 : population par âge (5 classes), par sexe et par région\nT6 : population par sexe, par diplôme et par région\nT7 : population par catégorie socio-professionnelle, par statut d’activité et par région\n\nEn formalisant :\n\nT1 : pop \\(\\bigotimes\\) {age x sexe x dep}\nT2 : pop \\(\\bigotimes\\) {age x dip x dep}\nT3 : pop \\(\\bigotimes\\) {socpro x act x dep}\nT4 : pop \\(\\bigotimes\\) {age x sexe x act}\nT5 : pop \\(\\bigotimes\\) {age x sexe x reg}\nT6 : pop \\(\\bigotimes\\) {sexe x dip x reg}\nT7 : pop \\(\\bigotimes\\) {socpro x act x reg}\n\nAnalyse\nLes tableaux partagent le même champ (sous-entendu) et le même indicateur (population), ils sont donc liés a minima par le total, donc il n’y a pas de sous-demande indépendante.\nDe plus, certains tableaux ont des variables de croisement communes, il y a un lien sur les marges, les liens n’en sont que renforcés.\nDeux variables ont un lien hiérarchique (région &gt; département), lorsque l’information est hiérarchisée (et emboîtée) il faut la traiter dans un même tableau en créant une variable hiérarchique qu’on peut appeler par exemple GEO. De plus, on peut fusionner les tableaux partageant les mêmes variables de croisement.\nLa liste des tableaux à protéger est donc la suivante :\n\nT1 : pop \\(\\bigotimes\\) {age x sexe x GEO}\nT2 : pop \\(\\bigotimes\\) {sexe x dip x GEO}\nT3 : pop \\(\\bigotimes\\) {socpro x act x GEO}\nT4 : pop \\(\\bigotimes\\) {age x sexe x act}\noù GEO est une variable hiérarchique emboîtant régions et départements\n\n\n\n3.2.3 Exemple 3 : niveau expert\nDemande - on souhaite diffuser 4 tableaux\n\nT1 : population par âge (3 classes : &lt;25, 25-55, +55) et par département\nT2 : population par âge (5 classes : &lt;15, 15-25, 25-45, 45-65, +65), par sexe et par département\nT3 : population par âge (3 classes : &lt;25, 25-55, +55) et par région\nT4 : population par âge (5 classes : &lt;15, 15-25, 25-45, 45-65, +65), par sexe et par région\n\nEn formalisant :\n\nT1 : pop \\(\\bigotimes\\) {age_3 x dep}\nT2 : pop \\(\\bigotimes\\) {age_5 x sexe x dep}\nT3 : pop \\(\\bigotimes\\) {age_3 x reg}\nT4 : pop \\(\\bigotimes\\) {age_5 x sexe x reg}\n\nAnalyse\nLes tableaux partagent le même champ (sous-entendu) et le même indicateur (population), ils sont donc liés a minima par le total, donc il n’y a pas de sous-demande indépendante.\nDe plus, certains tableaux ont des variables de croisement communes, il y a un lien sur les marges, les liens n’en sont que renforcés.\nDeux variables ont un lien hiérarchique (région &gt; département) :\n\nles tableaux T1 et T3 partagent les mêmes variables de croisement et peuvent donc être fusionnés\nles tableaux T2 et T4 partagent les mêmes variables de croisement et peuvent donc être fusionnés\n\nLa variable âge est ventilée différemment entre T1 et T2 (ainsi qu’entre T3 et T4). On doit donc se demander si les différentes modalités de l’âge sont emboîtées. On peut présenter la hiérarchie ainsi :\n\n&lt;25\n@&lt;15\n@15-25\n25-55\n@25-45\n@45-55\n+55\n@55-65\n+65\n\nIl n’est pas possible d’insérer la modalité 45-65 dans cette hiérarchie, il s’agit donc d’un cas de hiérarchie non-emboîtée. En effet, 45-65 = 45-55 + 55-65 est un agrégat non-emboîté qui devra être traité en construisant un tableau séparé.\nUne première étape d’analyse mène à la liste des tableaux à protéger suivante :\n\nT1 : pop \\(\\bigotimes\\) {AGE_hrc_princ x GEO}\nT1bis : pop \\(\\bigotimes\\) {AGE_hrc_spe x GEO}\nT2 : pop \\(\\bigotimes\\) {AGE_hrc_princ x sexe x GEO}\nT2bis : pop \\(\\bigotimes\\) {AGE_hrc_spe x sexe x GEO}\noù GEO est une variable hiérarchique emboîtant régions et départements\noù AGE_hrc_princ (hiérarchie principale) est une variable hiérarchique emboîtant l’ensemble des catégories d’âge hors 45-65\noù AGE_hrc_spe (agrégat spécial) a les modalités : 45-65 = 45-55 + 55-65\n\nOn remarque que T1 est en réalité déjà “contenu” dans T2. Puisque le croisement AGE_hrc_princ x GEO est présente dans T2. De même T1bis est contenu dans T2bis. On peut donc regrouper ces tableau. Finalement, on se retrouve avec cette liste de tableaux à protéger :\n\nT1 : pop \\(\\bigotimes\\) {AGE_hrc_princ x sexe x GEO}\nT2 : pop \\(\\bigotimes\\) {AGE_hrc_spe x sexe x GEO}\noù GEO est une variable hiérarchique emboîtant régions et départements\noù AGE_hrc_princ (hiérarchie principale) est une variable hiérarchique emboîtant l’ensemble des catégories d’âge hors 45-65\noù AGE_hrc_spe (agrégat spécial) a les modalités : 45-65 = 45-55 + 55-65"
  },
  {
    "objectID": "04_secret_tableaux_lies.html",
    "href": "04_secret_tableaux_lies.html",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "",
    "text": "4.1 Analyser les caractéristiques des tableaux",
    "crumbs": [
      "La pose de secret",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Poser le secret sur plusieurs tableaux liés</span>"
    ]
  },
  {
    "objectID": "04_secret_tableaux_lies.html#analyser-les-caractéristiques-des-tableaux",
    "href": "04_secret_tableaux_lies.html#analyser-les-caractéristiques-des-tableaux",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "4.1 Analyser les caractéristiques des tableaux",
    "text": "4.1 Analyser les caractéristiques des tableaux\n\n4.1.1 Détecter liens par les marges\nLes tableaux présentés ici ont la structure suivante :\n\nturnover_act_size: chiffre d’affaires ventilé par activité et taille de l’entreprise\nturnover_act_cj: chiffre d’affaires ventilé par activité et taille de l’entreprise\nturnover_nuts_size: chiffre d’affaires ventilé par nuts et taille de l’entreprise\nturnover_nuts_cj: chiffre d’affaires ventilé par nuts et catégorie juridique de l’entreprise\n\nIls sont liés par leurs marges:\n\nturnover_act_size et turnover_act_cj partagent les marges d’activité\nturnover_nuts_size et turnover_nuts_cj partagent les marges des nuts\nturnover_act_size et turnover_nuts_size partagent les marges de taille\nturnover_act_cj et turnover_nuts_cj partagent les marges de catégorie juridique\n\n\n\n4.1.2 Réperer les variables hiérarchiques\nLes variables ACTIVITY et NUTS sont hiérarchiques. Il faut donc constituer les fichiers argus nécessaires.\nLes tables de correspondance associées à ces variables sont présents dans le package : activity_corr_table et nuts23_fr_corr_table.\n\ndata(\"activity_corr_table\")\ndata(\"nuts23_fr_corr_table\")\n\nOn utilise ces tables de correspondance pour construire les fichiers hiérarchiques pour TauArgus.\n\nact_hrc_file &lt;- write_hrc2(activity_corr_table, \n                           file_name = \"tauargus_files/hrc/activity.hrc\")\n\nnuts_hrc_file &lt;- write_hrc2(nuts23_fr_corr_table, \n                           file_name = \"tauargus_files/hrc/nuts23.hrc\")\n\nCette fonction crée les fichiers hiérarchiques .hrc dans le répertoire indiqué dans l’argument file_name et retourne le chemin de ce document.\n\nact_hrc_file\n\n[1] \"tauargus_files/hrc/activity.hrc\"\n\nnuts_hrc_file\n\n[1] \"tauargus_files/hrc/nuts23.hrc\"\n\n\n\n\n4.1.3 Construire une liste de tableaux et une liste de variables de croisement\nDans le code ci-dessous, nous manipulons les objets list de R. Si ce type d’objets ne vous est pas familier, vous pouvez vous reporter à l’annexe 12 qui présente les listes et comment les manipuler.\n\nliste_4tabs &lt;- list(\n  act_size = turnover_act_size,\n  act_cj = turnover_act_cj,\n  nuts_size = turnover_nuts_size,\n  nuts_cj = turnover_nuts_cj\n)\n\n\nliste_vars_4tabs &lt;- purrr::map(\n  liste_4tabs,\n  function(data) colnames(data)[1:2]\n)\nstr(liste_vars_4tabs)\n\nList of 4\n $ act_size : chr [1:2] \"ACTIVITY\" \"SIZE\"\n $ act_cj   : chr [1:2] \"ACTIVITY\" \"CJ\"\n $ nuts_size: chr [1:2] \"NUTS\" \"SIZE\"\n $ nuts_cj  : chr [1:2] \"NUTS\" \"CJ\"\n\n\n\nAvertissement : il faut repérer les codes servant au total et de s’assurer qu’ils sont cohérents pour une même variable apparaissant dans plusieurs tableaux. En effet, deux tableaux partageant la même variable doivent utiliser la même modalité pour renseigner le total. On le vérifie en regardant les données.\n\nany(turnover_act_cj$CJ == \"Total\")\n\n[1] TRUE\n\nany(turnover_nuts_size$NUTS == \"Total\")\n\n[1] TRUE\n\nany(turnover_nuts_cj$NUTS == \"Total\")\n\n[1] TRUE\n\nany(turnover_nuts_cj$CJ == \"Total\")\n\n[1] TRUE\n\n\nIci il n’y a pas de problème puisque toutes les variables en commun ont une même modalité représentant les marges : “Total”."
  },
  {
    "objectID": "04_secret_tableaux_lies.html#sec-pose-secret-primaire",
    "href": "04_secret_tableaux_lies.html#sec-pose-secret-primaire",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "4.2 Poser le secret primaire sur chacun des tableaux",
    "text": "4.2 Poser le secret primaire sur chacun des tableaux\nLes règles de secret appliquées ici correspondent aux règles spécifiques aux statistiques entreprises. Pour en savoir plus sur les différentes règles existantes, reportez-vous à l’annexe 11.\n\nliste_4tabs &lt;- liste_4tabs %&gt;%\n  purrr::map(\n    function(df){\n      df %&gt;%\n        mutate(\n          is_secret_freq = N_OBS &gt; 0 & N_OBS &lt; 3,\n          is_secret_dom = (MAX != 0) & (MAX &gt; TOT*0.85),\n          is_secret_prim = is_secret_freq | is_secret_dom\n        )\n    }\n  )\n\nCe code est expliqué à l’annexe 12."
  },
  {
    "objectID": "04_secret_tableaux_lies.html#calculer-le-nombre-de-cellules-en-secret-primaire",
    "href": "04_secret_tableaux_lies.html#calculer-le-nombre-de-cellules-en-secret-primaire",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "4.3 Calculer le nombre de cellules en secret primaire",
    "text": "4.3 Calculer le nombre de cellules en secret primaire\nAvant de passer à l’étape suivante il est important de prendre connaissance de la quantité de secret primaire présent dans les tableaux. En effet, s’il y a beaucoup de secret primaire alors il y aura sans doute beaucoup de secret secondaire et donc vraisemblablement trop de cellules en secret. Dans ce cas-là, il est intéressant pour réduire le secret primaire de changer les tableaux en regroupant des variables ou des modalités.\n\nliste_4tabs %&gt;% purrr::walk(function(tab) count(tab, is_secret_prim) %&gt;% print())\n\n# A tibble: 2 × 2\n  is_secret_prim     n\n  &lt;lgl&gt;          &lt;int&gt;\n1 FALSE            337\n2 TRUE              77\n# A tibble: 2 × 2\n  is_secret_prim     n\n  &lt;lgl&gt;          &lt;int&gt;\n1 FALSE            346\n2 TRUE              60\n# A tibble: 2 × 2\n  is_secret_prim     n\n  &lt;lgl&gt;          &lt;int&gt;\n1 FALSE            388\n2 TRUE              72\n# A tibble: 2 × 2\n  is_secret_prim     n\n  &lt;lgl&gt;          &lt;int&gt;\n1 FALSE            387\n2 TRUE              65"
  },
  {
    "objectID": "04_secret_tableaux_lies.html#poser-le-secret-secondaire-avec-tab_multi_manager",
    "href": "04_secret_tableaux_lies.html#poser-le-secret-secondaire-avec-tab_multi_manager",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "4.4 Poser le secret secondaire avec tab_multi_manager()",
    "text": "4.4 Poser le secret secondaire avec tab_multi_manager()\nLa fonction tab_multi_manager() requiert les arguments suivants :\n\nlist_tables : liste de tables à protéger\nlist_explanatory_vars : liste des noms des variables de croisements présentes dans la liste des tables à protéger dans la table;\ndir_name : le nom du répertoire qui contiendra tous les fichiers créés, s’il n’existe pas, il sera créé (ex : dir_name = \"my_directory\").\nhrc : un vecteur nommé spécifiant le chemin vers le fichier .hrc pour chaque variable hiérarchique (ex : c(ACTIVITY = “chemin_vers_fichier/act.hrc”, NUTS = “chemin_vers_fichier/nuts.hrc” )).\nalt_hrc : une liste nommée utile pour traiter les hiérarchies non emboîtées. Les noms de la liste sont les noms des tableaux pour lesquelles une autre hiérarchie (non emboîtée en général) doit être utilisée (ex : si T1 et T2 ont une variable explicative, appelée ACTIVITY, et la même variable de réponse, mais la variable ACTIVITY n’a pas la même hiérarchie dans les les deux tables). Supposons que les hiérarchies (act1.hrc et act2.hrc) ne sont pas emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit :\n\nhrc = c(ACTIVITY = \"path_to_file/act_1.hrc\") : par défaut, cette hiérarchie sera utilisée pour la variable ACTIVITY.\nalt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\")) dans la table T2, la hiérarchie alternative sera utilisée.\n\ntotcode : le code du total pour chaque variable explicative. Il est recommandé d’utiliser le même code de total pour chaque variable. Si par exemple le code est “Total” pour toutes les variables. La syntaxe suivante est autorisée : totcode = “Total”. Sinon, l’input attendu est une liste spécifiant le code total pour chaque variable explicative (ex : totcode = list(ACTIVITY = “Total”, NUTS = “FR”, SIZE = “Ensemble”, CJ = “Total”))\n\nAttention : Si les totaux ne sont pas dans la table, ils seront calculés par Tau-Argus, mais ils ne seront pas éligibles pour la suppression primaire. Il est donc nécessaire de les fournir dans la table de départ.\n\nalt_totcode : une liste nommée pour les codes de totaux alternatifs (voir alt_hrc pour l’utilisation).\nvalue : le nom de colonne de la variable de réponse dans les tableaux, il DOIT être identique pour chaque table (ex : valeur = “turnover”). Valeur par défaut : “value”.\nfreq : le nom de colonne de la variable de fréquence dans les tableaux, il DOIT être le même nom pour chaque tableau (ex : freq = “frequency”). Valeur par défaut : “freq”.\nsecret_var : le nom de la variable booléenne spécifiant le secret primaire dans les tables, il DOIT être le même nom pour chaque table (ex : secret_var = “is_secret_prim”). Valeur par défaut : “is_secret_prim”.\n\n\nmasq_4tabs &lt;- tab_multi_manager(\n    list_tables = liste_4tabs,\n    list_explanatory_vars = liste_vars_4tabs,\n    dir_name = \"tauargus_files/4tabs\",\n    hrc = list(ACTIVITY = act_hrc_file, NUTS = nuts_hrc_file),\n    totcode = \"Total\",\n    value = \"TOT\",\n    freq = \"N_OBS\",\n    secret_var = \"is_secret_prim\"\n)"
  },
  {
    "objectID": "04_secret_tableaux_lies.html#analyser-les-résultats",
    "href": "04_secret_tableaux_lies.html#analyser-les-résultats",
    "title": "4  Poser le secret sur plusieurs tableaux liés",
    "section": "4.5 Analyser les résultats",
    "text": "4.5 Analyser les résultats\nAnalyser le journal\nLa fonction tab_multi_manager() fournit un journal décrivant l’ensemble des itérations réalisées lors du processus de protection. Il s’agit du fichier journal.txt dans le répertoire mentionné dans dir_name.\nPour chaque étape, sont indiqués :\n\nLe tableau sur lequel est posé sur le secret secondaire ;\nLe bilan du secret posé sur ce tableau ;\nLe nombre de cellules communes (c’est-à-dire appartenant à plusieurs tableaux) touchées.\n\nL’ensemble des cellules communes est listé en fin de processus.\nBilan du secret\nL’objet retourné par la fonction tab_multi_manager() est une liste contenant les mêmes tables que la liste placée en input auxquelles sont ajoutés les résultats des différentes étapes de la pose du secret secondaire. Ainsi, la dernière variable de chaque tableau permet de déterminer le statut final de chaque cellule.\nCe code crée une variable statut_final renvoyant les codes de la norme européenne :\n-   `A` les cellules en secret primaire à cause de la règle de\n    fréquence\n-   `B` les cellules en secret primaire à cause de la règle de\n    dominance\n-   `D` les cellules concernées par le secret secondaire\n-   `V` les cellules non touchées par le secret, c'est-à-dire les\n    cellules qui pourront être diffusées\n\nmasq_4tabs &lt;- masq_4tabs %&gt;% \n  purrr::map(\n    function(tab){\n      tab %&gt;% \n        rename_with(~\"is_secret_final\", last_col()) %&gt;% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_dom ~ \"B\",\n            is_secret_final ~ \"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_4tabs)\n\nList of 4\n $ act_size :'data.frame':  414 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ N_OBS          : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ TOT            : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_2    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_3    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_4    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ act_cj   :'data.frame':  406 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:406] \"01\" \"01\" \"01\" \"02\" ...\n  ..$ CJ             : chr [1:406] \"LL\" \"SP\" \"Total\" \"LL\" ...\n  ..$ N_OBS          : int [1:406] 9 9 18 240 147 387 1 1 1 3 ...\n  ..$ TOT            : num [1:406] 435 418 853 27625 15998 ...\n  ..$ MAX            : num [1:406] 263 303 303 6212 672 ...\n  ..$ is_secret_freq : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:406] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_size:'data.frame':  460 obs. of  14 variables:\n  ..$ NUTS           : chr [1:460] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ SIZE           : chr [1:460] \"Total\" \"tr1\" \"tr2\" \"tr3\" ...\n  ..$ N_OBS          : int [1:460] 38462 37329 1096 37 19469 18919 529 21 2725 2649 ...\n  ..$ TOT            : num [1:460] 33026385 13774596 7172793 12078996 19217180 ...\n  ..$ MAX            : num [1:460] 3084242 1013320 513792 3084242 3084242 ...\n  ..$ is_secret_freq : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:460] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_cj  :'data.frame':  452 obs. of  14 variables:\n  ..$ NUTS           : chr [1:452] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ CJ             : chr [1:452] \"LL\" \"PA\" \"SP\" \"Total\" ...\n  ..$ N_OBS          : int [1:452] 28705 1012 8745 38462 15372 983 3114 19469 1598 1 ...\n  ..$ TOT            : num [1:452] 24151930 26238 8848217 33026385 13207770 ...\n  ..$ MAX            : num [1:452] 1674878 5577 3084242 3084242 1674878 ...\n  ..$ is_secret_freq : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:452] \"V\" \"V\" \"V\" \"V\" ...\n\n\nOn peut ainsi dresser notre bilan par tableau :\n\nmasq_4tabs %&gt;% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %&gt;% \n        count(statut_final) %&gt;% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %&gt;% \n        relocate(table)\n    }\n  )\n\n       table statut_final   n      part\n1   act_size            A  52 12.560386\n2   act_size            B  25  6.038647\n3   act_size            D  83 20.048309\n4   act_size            V 254 61.352657\n5     act_cj            A  35  8.620690\n6     act_cj            B  25  6.157635\n7     act_cj            D  88 21.674877\n8     act_cj            V 258 63.546798\n9  nuts_size            A  55 11.956522\n10 nuts_size            B  17  3.695652\n11 nuts_size            D  82 17.826087\n12 nuts_size            V 306 66.521739\n13   nuts_cj            A  45  9.955752\n14   nuts_cj            B  20  4.424779\n15   nuts_cj            D 101 22.345133\n16   nuts_cj            V 286 63.274336"
  },
  {
    "objectID": "05_fiches_pratiques.html",
    "href": "05_fiches_pratiques.html",
    "title": "5  Fiches pratiques",
    "section": "",
    "text": "5.1 Structure des données\nTous les tableaux fournis en entrée de rtauargus ont une structure identique :\nN.B : pour les tableaux de fréquence FREQ = VALUE.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "05_fiches_pratiques.html#structure-des-données",
    "href": "05_fiches_pratiques.html#structure-des-données",
    "title": "5  Fiches pratiques",
    "section": "",
    "text": "Les variables décrivant les croisements (variables catégorielles) sont placées au début\nFREQ la variable indiquant le nombre d’unités statistiques contribuant à la cellule;\nVALUE la variable indiquant la somme pondérée des valeurs de l’ensemble des contributeurs à la cellule (ex : un chiffre d’affaires, un nombre de personnes en emploi au 31/12, etc.);\nMAX la valeur du plus gros contributeur à la cellule.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "05_fiches_pratiques.html#préparation-des-tableaux-pour-la-pose-du-secret",
    "href": "05_fiches_pratiques.html#préparation-des-tableaux-pour-la-pose-du-secret",
    "title": "5  Fiches pratiques",
    "section": "5.2 Préparation des tableaux pour la pose du secret",
    "text": "5.2 Préparation des tableaux pour la pose du secret\n\n\n\n\n\nNiveau facile\n\n\n\n5.2.1 tabulate_micro_data()\n\n5.2.1.1 Présentation\nPour la pose du secret, outre la valeur des cellules (que l’on nommera VALUE), il est nécessaire d’avoir des informations supplémentaires par rapport au tableau publié :\n\nFREQ : Le nombre d’unités statistiques ayant contribué à la cellule (pour déterminer le secret primaire de fréquence).\nMAX : La valeur du plus gros contributeur de la cellule (pour déterminer le secret primaire de dominance)\nles sous-totaux pour toutes les combinaisons possibles entre les variables. Par exemple, pour un tableau à 3 variables (A10 x SIZE x CJ)\n\n\n\n\nA10\nSIZE\nCJ\n\n\n\n\nTotal\nTotal\nTotal\n\n\nTotal\nTotal\n*\n\n\nTotal\n*\nTotal\n\n\n*\nTotal\nTotal\n\n\nTotal\n*\n*\n\n\n*\nTotal\n*\n\n\n*\n*\nTotal\n\n\n\nIl est possible de générer ce tableau soi-même. Mais pour faciliter la préparation de ces informations, le package rtauargus contient la fonction tabulate_micro_data pour le générer.\n\n\n5.2.1.2 arguments\n\ndf : jeu de données individuelles (data.frame ou data.table)\ncat_vars : Variables de croisements (catégorielles) non hiérarchiques (vecteur)\nhrc_vars : Variables de croisements hiérarchiques sous la forme d’une liste nommée\npond_var : Variable de pondération\nresp_var : Indicateur(s), variable(s) de réponse\nmarge_label : Label utilisé pour les marges (sous-totaux)\n\n\n\n5.2.1.3 résultat\n\nnb_obs : Comptage du nombre d’unités statistiques (FREQ)\nX_tot : Indicateur / variable de réponse (VALUE)\nX_max : Contribution maximale (MAX).\n\n\n\n\n5.2.2 Exemples\n\n5.2.2.1 Appel simple\nTrois variables de croisement (“A10”, “SIZE”, “CJ”) et une variable de réponse (“PRODUCTION”).\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n5.2.2.2 Variable de réponse pondérée\nDans le cas d’enquêtes non exhaustives, les observations sont pondérées. Pour indiquer la colonne de pondération, utiliser l’argument pond_var.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\", \"WEIGHT\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , pond_var = \"WEIGHT\"\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n5.2.2.3 Variable hiérarchique\nDans le cas de variables hiérarchiques (cf § 4.4), il faut utiliser l’argument hrc_vars.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\",\"A21\",\"A88\", \"SIZE\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"SIZE\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , hrc_vars = list(ACTIVITY = c(\"A10\",\"A21\",\"A88\"))\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n5.2.2.4 Deux indicateurs en même temps\nSi plusieurs tableaux, portant sur des variables d’intéret différentes mais ont les mêmes variables de croisement, il est possible de préparer les tableaux de secret en un seul appel à tabulate_micro_data, en fournissant un vecteur à l’argument resp_var.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"SIZE\", \"CJ\", \"TURNOVER\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(indiv_dt\n                                         , cat_vars = c(\"SIZE\", \"CJ\")\n                                         , resp_var = c(\"TURNOVER\", \"PRODUCTION\")\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n5.2.2.5 Tableaux de fréquence\nLes tableaux publiés sont souvent des tableaux de comptage. Par exemple, combien combien d’entreprises ont pour code NAF X. Ces tableaux sont un cas particulier. Leur VALUE est identique à leur FREQ et leur MAX n’a pas de signification. Lors de l’appel à la fonction tabulate_micro_data, on ne fournit pas de variable de réponse et la fonction ne retourne que le comptage.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "05_fiches_pratiques.html#prendre-en-compte-une-variable-hiérarchique",
    "href": "05_fiches_pratiques.html#prendre-en-compte-une-variable-hiérarchique",
    "title": "5  Fiches pratiques",
    "section": "5.3 Prendre en compte une variable hiérarchique",
    "text": "5.3 Prendre en compte une variable hiérarchique\n\n\n\n\n\nNiveau facile\n\n\nReprenons ici l’exemple de la variable geo qui est une variable hiérarchique puisqu’il existe des emboîtements entre les différents niveaux.\n\n\n\n\n\nflowchart TD\n  A[Pays] --&gt; B[Nord]\n  A --&gt; C[Ouest]\n  A --&gt; D[Est]\n  A --&gt; E[Sud]\n  B --&gt; F[N1]\n  B --&gt; G[N2]\n  B --&gt; H[N3]\n  C --&gt; I[O1]\n  C --&gt; J[O2]\n  C --&gt; K[O3]\n  C --&gt; L[O4]\n  D --&gt; M[E1]\n  D --&gt; N[E2]\n  D --&gt; O[E3]\n  E --&gt; P[S1]\n  E --&gt; Q[S2]\n\n\n\n\n\n\nPour prendre en compte cette hiérarchie il faut d’abord pouvoir la représenter de telle sorte que Tau-Argus comprenne les différents emboîtements présents.\n\n5.3.1 Première option\nLa première option consiste à créer le fichier nécessaire (extension .hrc) à la main. Ceci est tout à fait pertinent si la hiérarchie n’est pas trop étendue.\nTau-Argus attend en effet un type de fichier bien particulier, dont l’extension est .hrc. Il s’agit d’un simple fichier texte où les différents emboîtements sont écrits les uns en-dessous des autres. Un symbole (le @) est utilisé pour préciser le niveau de chacun des emboîtements au sein de la hiérarchie.\nDans notre exemple on écrirait le fichier de la façon suivante :\n\nNord\n@N1\n@N2\n@N3 \nOuest \n@O1 \n@O2 \n@O3 \n@O4 \nEst\n@E1 \n@E2 \n@E3 \nSud \n@S1 \n@S2\n\nOn remarque que le total Pays n’est pas inclus dans le fichier .hrc c’est parce qu’il ne faut pas indiquer le super-total de la hiérarchie à Tau-Argus.\n\n\n5.3.2 Seconde option\nQuand la hiérarchie est très étendue, l’écriture manuelle du fichier de hiérarchie est pénible. Or, quand ce genre de cas se présente, il existe souvent une table de correspondance permettant d’associer les différents niveaux entre eux.\nNous appelons table de correspondance une table qui précise l’ensemble des niveaux associés aux emboîtements les plus fins.\nLa table de correspondance représentant la hiérarchie ci-dessus est la suivante:\n\npays_corr_table &lt;- tibble(\n  niv0 = \"Pays\",\n  niv1 = c(rep(\"Nord\",3),rep(\"Ouest\",4),rep(\"Est\",3), rep(\"Sud\",2)),\n  niv2 = c(paste0(\"N\",1:3),paste0(\"O\",1:4),paste0(\"E\",1:3), paste0(\"S\",1:2))\n)\npays_corr_table\n\n# A tibble: 12 × 3\n   niv0  niv1  niv2 \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 Pays  Nord  N1   \n 2 Pays  Nord  N2   \n 3 Pays  Nord  N3   \n 4 Pays  Ouest O1   \n 5 Pays  Ouest O2   \n 6 Pays  Ouest O3   \n 7 Pays  Ouest O4   \n 8 Pays  Est   E1   \n 9 Pays  Est   E2   \n10 Pays  Est   E3   \n11 Pays  Sud   S1   \n12 Pays  Sud   S2   \n\n\nAvec la fonction write_hrc2() du package rtauargus, on peut transformer la table de correspondance en un fichier hrc.\n\nwrite_hrc2(pays_corr_table %&gt;% select(-niv0), file_name = \"hrc/pays_TA_2.hrc\")\n\nRemarque: La fonction rtauargus::write_hrc2() n’accepte pas de valeurs manquantes dans la table en entrée. Lorsqu’une hiérarchie n’a pas la même nombre de sous-niveaux selon les branches on répète la modalité du niveau supérieur sur les niveaux inférieurs pour ne pas avoir de cases vides.\nExemple : pour la hiérarchie ci-dessous on répète la modalité C dans la table de correspondance.\n\n\n\n\n\nflowchart TD\n  A[Total] --&gt; B[A]\n  A --&gt; C[B]\n  A --&gt; D[C]\n  B --&gt; E[A1]\n  B --&gt; F[A2]\n  C --&gt; G[B1]\n  C --&gt; H[B2]\n  H --&gt; I[B21]\n  H --&gt; J[B22]\n\n\n\n\n\n\n\ncorr_tab &lt;- tibble(\n  niv0 = \"ALL\",\n  niv1 = c(rep(\"A\",2),rep(\"B\",3), \"C\"),\n  niv2 = c(\"A1\",\"A2\",\"B1\",rep(\"B2\",2), \"C\"),\n  niv3 = c(\"A1\",\"A2\",\"B1\", \"B21\", \"B22\", \"C\")\n)\ncorr_tab\n\n# A tibble: 6 × 4\n  niv0  niv1  niv2  niv3 \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 ALL   A     A1    A1   \n2 ALL   A     A2    A2   \n3 ALL   B     B1    B1   \n4 ALL   B     B2    B21  \n5 ALL   B     B2    B22  \n6 ALL   C     C     C",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "05_fiches_pratiques.html#poser-le-secret-en-présence-de-hiérarchies-non-emboîtées",
    "href": "05_fiches_pratiques.html#poser-le-secret-en-présence-de-hiérarchies-non-emboîtées",
    "title": "5  Fiches pratiques",
    "section": "5.4 Poser le secret en présence de hiérarchies non-emboîtées",
    "text": "5.4 Poser le secret en présence de hiérarchies non-emboîtées\n\n\n\n\n\nNiveau moyen\n\n\nLorsque l’on a la présence de hiérarchie non-emboîtée dans les tableaux traités alors il faut construire deux tableaux et deux hiérarchies pour chaque hiérarchie non-emboîtée.\nPar exemple, le tableau turnover_act_size croise la NAF et les tranches d’effectifs des entreprises. Si l’on décide de publier, en plus des activités classiques de la NAF, un agrégat supplémentaire \\(AGREG = AZ + B\\), alors il faut construire un tableau supplémentaire avec cet agrégat. En effet, AGREG ne peut pas s’insérer dans la hiérarchie NAF, il faut donc construire deux hiérarchies :\n\nla hiérarchie NAF (principale)\nla hiérarchie de l’agrégat supplémentaire (alternative)\n\nOn crée le fichier .hrc de la hiérarchie principale à partir de la table de correspondance incluse dans le package.\n\nstr(activity_corr_table)\n\n'data.frame':   92 obs. of  3 variables:\n $ A10: chr  \"AZ\" \"AZ\" \"AZ\" \"BE\" ...\n $ A21: chr  \"A\" \"A\" \"X\" \"B\" ...\n $ A88: chr  \"01\" \"02\" \"X\" \"06\" ...\n\n\n\nwrite_hrc2(activity_corr_table, file_name = \"hrc/NAF_principale.hrc\")\n\nPuis on crée la hiérarchie alternative pour l’agrégat spécifique\n\nalt_corr_table &lt;- tibble::tibble(\n  niv0 = \"AGREG\",\n  niv1 = c(\"B\",\"AZ\")\n)\n\nwrite_hrc2(alt_corr_table %&gt;% select(-niv0), file_name = \"hrc/AGREG_alt.hrc\")\n\nOn construit les tableaux nécessaires à la pose du secret et on leur applique le secret primaire. A savoir le tableau sur lequel la hiérarchie principale sera appliquée.\n\nturnover_act_size_detect &lt;-  turnover_act_size %&gt;%\n  rename(FREQ = N_OBS, VALUE = TOT) %&gt;% \n  mutate(\n    is_secret_freq = FREQ &gt; 0 & FREQ &lt; 3,\n    is_secret_dom = (VALUE != 0) & (MAX &gt; 0.85*VALUE)\n  ) %&gt;% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\nEt le tableau sur lequel la hiérarchie alternative sera appliquée, i.e. tableau uniquement avec les modalités présentes dans la hiérarchie alternative et on pose le secret primaire.\n\ntrunover_act_size_alt &lt;- turnover_act_size_detect %&gt;% \n  filter(ACTIVITY %in% c(\"AZ\",\"B\"))\n\n\n\n\n\n\n\nArguments tab_multi_manager() pour traiter les hiérarchies non-emboîtées\n\n\n\n\nalt_totcode : une liste nommée pour les codes de totaux alternatifs (voir alt_hrc pour l’utilisation).\nalt_hrc : une liste nommée utile pour traiter les hiérarchies non emboîtées. Les noms de la liste sont les noms des tableaux pour lesquelles une autre hiérarchie (non emboîtée en général) doit être utilisée (ex : si T1 et T2 ont une variable explicative, appelée ACTIVITY, et la même variable de réponse, mais la variable ACTIVITY n’a pas la même hiérarchie dans les les deux tables). Supposons que les hiérarchies (act1.hrc et act2.hrc) ne sont pas emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit :\n\nhrc = c(ACTIVITY = \"chemin_vers_fichier/act_1.hrc\") : par défaut, cette hiérarchie sera utilisée pour la variable ACTIVITY.\nalt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\")) dans la table T2, la hiérarchie alternative sera utilisée.\n\n\n\n\n\nmasq_nonemb &lt;- tab_multi_manager(\n  list_tables = list(\n    tab = turnover_act_size_detect,\n    tab_alt = trunover_act_size_alt\n    ),\n  list_explanatory_vars = list(\n    tab = c(\"ACTIVITY\",\"SIZE\"),\n    tab_alt = c(\"ACTIVITY\",\"SIZE\")\n    ),\n  dir_name = \"tauargus_files/hrc_nonemb\",\n  hrc = list(ACTIVITY = \"hrc/NAF_principale.hrc\"),\n  alt_hrc = list(\n    tab_alt = c(ACTIVITY = \"hrc/AGREG_alt.hrc\")\n    ),\n  totcode = \"Total\",\n  alt_totcode = list(\n    tab_alt = c(ACTIVITY = \"AGREG\")\n    ),\n  value = \"VALUE\",\n  freq = \"FREQ\",\n  secret_var = \"is_secret_prim\"\n)\n\n\nmasq_nonemb &lt;- masq_nonemb %&gt;% \n  purrr::map(\n    function(tab){\n      tab %&gt;% \n        rename_with(~\"is_secret_final\", last_col()) %&gt;% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_dom ~ \"B\",\n            is_secret_final ~ \"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_nonemb)\n\nList of 2\n $ tab    :'data.frame':    414 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ FREQ           : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ VALUE          : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ tab_alt:'data.frame':    6 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:6] \"AZ\" \"AZ\" \"AZ\" \"B\" ...\n  ..$ SIZE           : chr [1:6] \"Total\" \"tr1\" \"tr2\" \"Total\" ...\n  ..$ FREQ           : int [1:6] 405 399 6 91 75 16\n  ..$ VALUE          : num [1:6] 44475 36356 8120 1171962 1051660 ...\n  ..$ MAX            : num [1:6] 6212 6212 4812 990201 990201 ...\n  ..$ is_secret_freq : logi [1:6] FALSE FALSE FALSE FALSE FALSE FALSE\n  ..$ is_secret_dom  : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_prim : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_1    : logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ is_secret_final: logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ statut_final   : chr [1:6] \"V\" \"V\" \"V\" \"V\" ...\n\n\nOn peut dresser le bilan :\n\nmasq_nonemb %&gt;% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %&gt;% \n        count(statut_final) %&gt;% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %&gt;% \n        relocate(table)\n    }\n  )\n\n    table statut_final   n      part\n1     tab            A  52 12.560386\n2     tab            B  25  6.038647\n3     tab            D  78 18.840580\n4     tab            V 259 62.560386\n5 tab_alt            B   1 16.666667\n6 tab_alt            D   1 16.666667\n7 tab_alt            V   4 66.666667",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "05_fiches_pratiques.html#utiliser-les-coûts",
    "href": "05_fiches_pratiques.html#utiliser-les-coûts",
    "title": "5  Fiches pratiques",
    "section": "5.5 Utiliser les coûts",
    "text": "5.5 Utiliser les coûts\n\n\n\n\n\n\nNiveau expert\n\n\n\n\n\n\nObjectif : apprendre à utiliser l’option cost du package rtauargus afin de rediriger le secret secondaire.\nTau-Argus utilise des algorithmes d’optimisation afin de minimiser la perte d’information qui résulte du secret secondaire. La question qui se pose est quelle valeur doit-être minimiser ? Plusieurs choix sont possibles, la valeur des cellules, le nombre de cellules, les effectifs des cellules. Il est également possible de personnaliser les coûts si l’on souhaite prioriser la pose de secret secondaire sur certains agrégats.\n\n5.5.1 Minimiser la valeur secrétisée\nTau-Argus minimise par défaut la valeur des cellules supprimées. C’est ce qui est le plus cohérent, lorsque l’on publie un tableau c’est bien la valeur des cellules qui nous intéresse.\n\n\n5.5.2 Minimiser le nombre de cellules secrétisées\nPour minimiser le nombre de cellules secrétisées il faut utiliser le paramètre cost et donc le définir dans notre table. si l’on souhaite minimiser le nombre de cellules masquées, il faut alors que le coût de suppression de chaque cellule soit identique, Tau-Argus considère alors qu’elles ont toutes la même importance. Pour cela il faut créer une colonne “cost” qui vaut 1 pour toutes les cellules de notre tableau.\n\n\n5.5.3 Minimiser les effectifs secrétisés\nOn peut aussi considérer que la valeur importante des cellules sont leurs effectifs. On peut penser qu’un nombre de répondants élevé pour une cellule lui confère une plus grande fiabilité statistique. Pour cela il suffit simplement de recopier la colonne “freq” dans notre colonne “cost”.\n\n\n5.5.4 Orienter le secret secondaire\nDans certaines données on peut trouver des agrégats jugés non significatifs. Ces derniers ne seront pas publiés dans les tableaux mais notés “ns”. On peut alors s’en servir pour la pose du secret secondaire.\nAttention, on pourrait penser que ces cellules devraient être placées en secret primaire, afin qu’elles soient considérées comme masquées quoi qu’il arrive. Cependant, cela peut entraîner plus de secret secondaire que nécessaire sachant qu’il n’est pas nécessaire de protéger ces cellules du risque de recoupement. L’utilisateur peut retrouver la valeur de ces cellules, mais il est averti qu’elles n’ont aucune importance statistique.\nPour prioriser le secret secondaire on crée donc pour les agrégats non-significatifs la colonne “cost” qui vaut 1. C’est le coût minimal, ceci indiquera à Tau-Argus que ces agrégats sont donc prioritaires pour le secret secondaire. Ainsi, certains coûts ne seront pas définis. Ce n’est pas un problème, lorsque l’on ne spécifie pas de coût pour une cellule, Tau-Argus va considérer que son coût de suppression est égal à la valeur de cette dernière.\nExemple\nSi par exemple, on souhaite prioriser le secret sur la tranche d’effectif 1 tr1 dans turnover_act_size, tableau intégré à rtauargus.\nTout d’abord, on pose le secret primaire sur le tableau.\n\ndata(\"turnover_act_size\")\n\nturnover_act_size_detect &lt;-  turnover_act_size %&gt;%\n  rename(FREQ = N_OBS, VALUE = TOT) %&gt;% \n  mutate(\n    is_secret_freq = FREQ &gt; 0 & FREQ &lt; 3,\n    is_secret_dom = (VALUE != 0) & (MAX &gt; 0.85*VALUE)\n  ) %&gt;% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\nPuis, on assigne on assigne la valeur 1 pour le coût de tous les croisements avec tr1.\n\nturnover_act_size_ns &lt;- turnover_act_size_detect %&gt;%\n  mutate(cost = ifelse(SIZE == \"tr1\", 1, VALUE))\nstr(turnover_act_size_ns)\n\ntibble [414 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE          : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ          : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE         : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX           : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n $ is_secret_freq: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n\n\nOn vérifie que les coûts à 1 ont bien été appliqués.\n\nstr(turnover_act_size_ns %&gt;% filter(cost == 1))\n\ntibble [113 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:113] \"Total\" \"AZ\" \"BE\" \"FZ\" ...\n $ SIZE          : chr [1:113] \"tr1\" \"tr1\" \"tr1\" \"tr1\" ...\n $ FREQ          : int [1:113] 217053 399 11485 26937 59426 7884 8026 11850 39819 26291 ...\n $ VALUE         : num [1:113] 1.01e+08 3.64e+04 4.69e+06 4.55e+06 1.10e+07 ...\n $ MAX           : num [1:113] 10018017 6212 990201 225864 765244 ...\n $ is_secret_freq: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:113] 1 1 1 1 1 1 1 1 1 1 ...\n\n\nOn pose le secret secondaire à l’aide de la fonction tab_rtauargus().\n\nres_ns &lt;- tab_rtauargus(\n  turnover_act_size_ns,\n  files_name = \"couts\",\n  dir_name = \"tauargus_files/couts\",\n  explanatory_vars = c(\"ACTIVITY\",\"SIZE\"),\n  totcode = c(\"Total\",\"Total\"),\n  freq = \"FREQ\",\n  value = \"VALUE\",\n  secret_var = \"is_secret_prim\",\n  cost_var = \"cost\",\n  verbose = FALSE\n)\n\nOn peut ensuite créer une synthèse du secret posé.\n\nsynthese_ns &lt;- res_ns %&gt;% group_by(Status) %&gt;%\n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  ) %&gt;% \n  group_by(statut_final) %&gt;% \n  summarise(\n    nb_cellules = n(),\n    effectif = sum(FREQ),\n    valeur = sum(VALUE)\n  )\n\nsynthese_ns\n\n# A tibble: 4 × 4\n  statut_final nb_cellules effectif      valeur\n  &lt;chr&gt;              &lt;int&gt;    &lt;int&gt;       &lt;dbl&gt;\n1 A                     52       76   22115262.\n2 B                     25    15219   37823909.\n3 D                     46   115266  142992327.\n4 V                    291  1667583 1259310983.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fiches pratiques</span>"
    ]
  },
  {
    "objectID": "06_expert.html",
    "href": "06_expert.html",
    "title": "6  Présentation des outils",
    "section": "",
    "text": "6.1 Tau-argus",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "06_expert.html#tau-argus",
    "href": "06_expert.html#tau-argus",
    "title": "6  Présentation des outils",
    "section": "",
    "text": "6.1.1 Présentation générale\nTau-Argus est la logiciel de référence en Europe en termes de pose de secret. Il permet de calculer le secret primaire et secondaire ou de faire des arrondis contrôlés. Le développement, la maintenance et le support de Tau-Argus sont réalisés par un groupe d’experts européens et est coordonné par CBS (l’institut national de statistiques des Pays-Bas). C’est un logiciel libre et open source (https://github.com/sdcTools/tauargus) utilisable via une interface graphique.\n\n\n6.1.2 Les différents algorithmes du secret secondaire\nPlusieurs algorithmes sont implémentes dans Tau-Argus pour gérer le secret secondaire. La méthode Hypercube permet un traitement séquentiel des cases sous secret primaire, en minimisant le coût. Dans le cas d’une hiérarchie, elle traite les sous-tableaux indépendamment. Il s’agit d’une méthode heuristique et rapide. Elle a l’avantage de proposer un masque rapidement mais celui-ci n’est pas le plus optimal. La méthode Optimal met en place une minimisation globale du coût et respecte les intervalles de protection. C’est une méthode souvent très lente. Enfin, la méthode Modular éclate le problème en différents sous-tableaux sur lesquels elle applique la méthode Optimal. Les variables doivent être hiérarchiques (pourquoi ?). C’est une méthode assez rapide que l’on utilise dans la plupart des cas.\n\n\n6.1.3 Avantages et inconvénients\nTau-Argus comporte de nombreux avantages, il s’agit d’un outil qui fait référence, performant sur la partie pose de secret et il est maintenu régulièrement. Cependant, il a des limites. En effet, l’interface est assez fouillis, il renvoie des bugs et des erreurs pas toujours facile à comprendre et corriger, enfin la reproductibilité des opérations est limitée.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "06_expert.html#package-rtauargus",
    "href": "06_expert.html#package-rtauargus",
    "title": "6  Présentation des outils",
    "section": "6.2 Package rtauargus",
    "text": "6.2 Package rtauargus\nBien que l’usage standard de Tau-Argus se fasse par une interface graphique, la prise en main n’est pas aisée. Ainsi, un package R a été développé à l’Insee pour travailler avec Tau-Argus depuis R : rtauargus. Il permet de bénéficier des avantages de Tau-Argus tout en limitant les inconvénients.\n\n6.2.1 Objectifs\nLe but de ce package est de faciliter la prise en main de Tau-Argus. Ainsi, il permet de poser le secret secondaire avec Tau-Argus sans l’ouvrir et gérer de grosses demandes.\n\n\n6.2.2 Principales fonctionnalités\nLe package a deux fonctionnalités principales : il permet de poser le secret directement sur les tableaux ou à partir des microdonnées. Le fonctionnement général du package est le suivant : création de l’ensemble des fichiers dans les formats attendus par Tau-Argus, lancement de Tau-Argus puis récupération des résultats dans R.\nLa démarche utilisée à la DMRG consiste à poser le secret primaire “manuellement”, c’est-à-dire sans faire appel à Tau-Argus et d’ensuite poser le secret secondaire à l’aide de la fonction tab_rtauargus() pour protéger un seul tableau et tab_multi_manager() pour protéger plusieurs tableaux.\n\n\n6.2.3 Où trouver la documentation ?\nLe documentation est disponible en ligne : https://inseefrlab.github.io/rtauargus/",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "06_expert.html#les-limites-de-tau-argus",
    "href": "06_expert.html#les-limites-de-tau-argus",
    "title": "6  Présentation des outils",
    "section": "6.3 Les limites de Tau-Argus",
    "text": "6.3 Les limites de Tau-Argus\n\n6.3.1 Le nombre de variables de ventilation\nActuellement \\(\\tau\\)-Argus tolère au maximum 4 variables de ventilation par tableau. Cependant, pour 4 variables de ventilation un warning apparaît, \\(\\tau\\)-Argus ne garantit pas une protection totale de la table. Effectuer un contrôle de cohérence sur le secret pour un tableau avec 4 dimensions est très complexe.\nPour pallier cette limitation, le package rtauargus permet de transformer des tableaux de 4 ou 5 dimensions en tableaux de 3 dimensions. Pour cela, il suffit de renseigner l’argument split_tab = TRUE lors de l’appel de tab_multi_manager() ou tab_rtauargus()\n\ndtMasque &lt;- tab_rtauargus(tabular = dtTableau\n              , explanatory_vars = c(\"NAF\", \"GEO\", \"CJ\", \"TREFF\", \"TRAGE\")\n              , files_name = \"tableauSecretise\"\n              , dir_name = \"c:/\"\n              , totcode = c(\"Total\", \"Total\", \"Total\", \"Total\", \"Total\")\n              , secret_var = \"is_secret_prim\"\n              , value = \"VALUE\"\n              , freq = \"FREQ\"\n              , maxscore = \"MAX\"\n              , split_tab = TRUE)\n\nPour aller plus loin, vous trouverez une vignette très complète sur le sujet dans le package rtauargus. (rtauargus/doc/split_tab_fr.html)\n\n\n6.3.2 Les valeurs trop élevées\n\\(\\tau\\)-Argus ne parvient pas à traiter un tableau s’il rencontre une cellule d’une valeur trop élevée.Dans le cas où une celulle du tableau viendrait à dépasser \\(10^{12}\\), un message d’erreur apparaîtra lors de la pose du secret secondaire. Afin d’éviter ce genre de problème, il est conseillé de regarder si le plus gros total du tableau dépasse \\(10^{12}\\), le cas échéant nous recommandons de diviser la valeur de votre tableau par une puissance de 10 adéquate. Cependant cela implique de faire attention à plusieurs choses :\n\nTraiter le secret primaire dans le fichier d’apriori avant d’arrondir les valeurs.\nS’assurer qu’aucune valeur n’est arrondie à 0, elle ne serait alors plus prise en compte lors du traitement du secret secondaire, dans ce cas il faut forcer un arrondi à 1 minimum.\nSi la valeur du plus gros contributeur est encore présente dans la table, l’arrondir avec le même ordre de grandeur que la variable de réponse.\n\nA ce jour, aucune limite n’a été constatée en terme de nombre de décimales, la piste reste à explorer. Mais nous recommandons tout de même d’arrondir les valeurs. Dans tous les cas les arrondis n’impacteront que très peu la pose du secret.\n\n\n6.3.3 Les limites du fichier hiérarchique\nLE NOMBRE DE CARACTÈRES DES FEUILLES\nAu sein d’un fichier .hrc, \\(\\tau\\)-Argus a besoin qu’au niveau hiérarchique le plus fin les feuilles aient le même nombre de caractères. Par exemple la hiérarchie suivante renverra un message d’erreur :\n\nA\n@A01\n@A02\n@A3\n\nLa fonction write_hrc2() permet d’ajouter des * dans la hiérarchie et les modalités du tableau afin d’éviter ce genre d’erreurs. Afin que ce soit le plus robuste possible cette transformation est appliquée à tous les niveaux hiérarchiques. Pour l’exemple précédent on obtiendra alors la hiérarchie :\n\n***A\n@A01\n@A02\n@*A3\n\nLES FEUILLES UNIQUES\nLors de la reconstitution des totaux de la table par \\(\\tau\\)-Argus, on obtient une erreur si la hiérarchie contient ce qu’on va appeler une “feuille unique”. Par exemple dans la hiérarchie :\n\nA\n@A1\n@@A11\n@@A12\n\nA1 sera ce qu’on appelle une feuille unique, c’est le seul sous-niveau de A. Ce problème n’est présent que lorsqu’on traite des données tabulées, la solution que nous utilisons actuellement est de créer une feuille fictive dans la hiérarchie. Nous n’avons pas de fonction qui automatise ce traitement actuellement mais nous allons probablement en développer une prochainement (est-ce tjr le cas ou c’est fait automatiquement dans write_hrc2() maintenant ?). La nouvelle hiérarchie sera la suivante :\n\nA\n@AX\n@A1\n@@A11\n@@A12\n\nIl n’y a pas besoin de modifier le tableau l’agrégat AX vaudra 0 et le traitement de la table s’effectuera correctement.\n\n\n6.3.4 Le nombre de modalités\nDans \\(\\tau\\)-Argus, le nombre de modalités au sein d’un même niveau hiérarchique est limité.\nVARIABLE NON HIÉRARCHIQUE\nPour une variable non hiérarchique \\(\\tau\\)-Argus ne peut pas traiter plus de 199 modalités (200 en comptabilisant le Total). Par exemple, un tableau au niveau communal avec donc 35 000 communes ne pourra pas être traité directement via \\(\\tau\\)-Argus. Les solutions que nous conseillons actuellement sont :\n\nDe découper le tableau en divers sous-tableau afin de respecter ce nombre de modalités maximum.\nD’insérer une variables hiérarchique qui permettra de respecter les critères décrits ci-dessous. Cela implique de traiter les nouveaux niveaux hiérarchiques comme des variables non diffusées.\n\nVARIABLE HIÉRARCHIQUE\nPour une variable hiérarchique il faut qu’il y ait moins de 200 modalités par niveau de la hiérarchie. Considérons la hiérarchie Région &gt; Département &gt; Commune, pour que \\(\\tau\\)-Argus puisse poser le secret secondaire :\n\nIl faut moins de 200 régions.\nDans une région donnée, il faut moins de 200 départements.\nDans un département donné, il faut moins de 200 communes.\n\nCependant, les zonages géographiques français ne respectent pas ces limites.\nDans notre exemple, dans chaque département il y a plus de 200 communes, le traitement hiérarchique tel quel est donc impossible. Une solution envisageable serait de rajouter un niveau hiérarchique en plus afin de réduire le nombre de commune sau même niveau. On peut penser ici par exemple aux cantons puisque qu’un département contient au maximum 43 cantons et un canton contient au maximum 135 communes. On pourrait alors traiter le hiérarchie Région &gt; Département &gt; Canton &gt; Commune. Les cellules concernant les cantons devront être traitées comme des cellules non diffusées et donc être prioritaires au niveau du secret secondaire. C’est-à-dire qu’à choisir on indiquera au programme de secrétiser plutôt un canton que tout autre zonage géographique\n\n\n6.3.5 Les algorithmes de secret secondaire\nDans certains cas assez particuliers, il se peut qu’un algorithme de secret secondaire ne puisse pas trouver de solution au problème en entrée. Étant donné que nous recommandons d’utiliser Modular en priorité, si jamais l’algorithme ne parvient pas à trouver de solution il faut alors tester Optimal puis HyperCube. Si aucun de ces trois algorithmes ne parvient à trouver de solution, cela vient généralement d’une grande table qui contient énormément de secret primaire. Dans ce cas nous recommandons de reconsidérer le problème. Cela vaut-il vraiment la peine de diffuser une table à un niveau aussi fin avec autant de secret primaire ? Il est peut être préférable d’agréger les données afin d’avoir moins de secret primaire.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "06_expert.html#les-codes-derreur-dans-tau-argus",
    "href": "06_expert.html#les-codes-derreur-dans-tau-argus",
    "title": "6  Présentation des outils",
    "section": "6.4 Les codes d’erreur dans Tau-Argus",
    "text": "6.4 Les codes d’erreur dans Tau-Argus\nCette partie n’est pas exhaustive mais recense les codes d’erreurs que nous avons rencontré en utilisant Tau-Argus.\nLes différentes causes possibles du message “code not in codelist” sont les suivantes :\n\nUne modalité d’une variable hiérarchique est présente dans la table mais pas dans le fichier hiérarchique associé\nLes noms de colonnes spécifiés pour le paramètre specify_tables de la fonction tab_arb() ne sont pas dans le même ordre que dans le tableau\n\nLe message d’erreur “illegal status in transition” est lié à l’apriori. Voici les différentes causes possibles :\n\nUne cellule possède deux status contradictoires dans le fichier d’apriori (ex : A01,s et A01,u). La cellule ne pouvant pas avoir deux status à la fois, Tau-Argus ne peut pas comprendre le statut de la cellule\nUne cellule avec une valeur nulle et un effectif nul est renseignée comme unsafe (u)\n\nLes différentes causes possibles du message d’erreur “error making totals” sont :\n\nOn a écrit dans le batch  et donc les totaux dans le tableau ne sont pas égaux à la somme des éléments qui le composent, autrement dit la table n’est pas additive\nOn écrit dans le batch  1 et donc Tau-Argus reconstitue lui-même les totaux. Cela vient généralement du problème des feuilles uniques décrit dans la partie précédente.\n\nLe message d’erreur “HiTaS: couldn’t load JJ-routines” est spécifique à l’aglorithme Modular, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (faire référence)\nLe problème paraît insoluble pour Modular (faire référence)\nN.B : parfois “couldn’t load JJ-routines” (sans HiTaS devant) renvoie à un problème lié à la hiérarchie (sans doute impossibilité de reconstituter la hiérarhcie à partir des données en entrée)\n\nLe message d’erreur “no optimal solution found JJ not loaded” est spécifique à l’aglorithme Optimal, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (faire référence)\nLe problème paraît insoluble pour Optimal (faire référence)\n\nLe message d’erreur “the hypercube could not be applied See file PROTO002” est spécifique à l’aglorithme HyperCube, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (faire référence)\nLe problème paraît insoluble pour HyperCube (faire référence)\n\nPour le message ” error in modular suppression procedure” il faut bien faire attention que c’est le message d’erreur présent dans le batch :\n\nGénéralement quand c’est l’unique message d’erreur, alors c’est que Modular a tourné pendant quelques minutes puis a atteint une limite de mémoire dans Tau-Argus\nfaire référence et tester avec un autre algorithme",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "06_expert.html#savoir-lire-les-différents-types-de-fichiers-spécifiques-à-tau-argus",
    "href": "06_expert.html#savoir-lire-les-différents-types-de-fichiers-spécifiques-à-tau-argus",
    "title": "6  Présentation des outils",
    "section": "6.5 Savoir lire les différents types de fichiers spécifiques à Tau-Argus",
    "text": "6.5 Savoir lire les différents types de fichiers spécifiques à Tau-Argus\nFichiers en sortie de rtauargus :\n\n.rda : fichier de métadonnées pour Tau-Argus\n.tab : fichier donné à Tau-Argus, il est décrit par .rda, les colonnes sont dans l’ordre des nom dans .rda\n.hst : fichier de l’apriori, avec rtauargus on pose le secret primaire en amont, on ne demande pas à Tau-Argus de le faire. Dans ce fichier on a à la fois le secret de départ, le “protection level” et les coûts (c)\n.arb : fichier executé dans la console windows, il est interprété par Tau-Argus. Autrement dit, ce sont une liste de commandes données à Tau-Argus\n\nFichiers en sortie de Tau-Argus :\n\n.txt : journal d’exécution, il n’écrase pas les exécutions ainsi on peut voir toutes les exécutions jamais faites avec Tau-Argus\n.csv : données d’entrée avec deux nouvelles colonnes. La colonne status à trois modalités : “B” = secret apriori (u), “D” = secret secondaire, “V” = cellules valides, diffusables. La colonne dom renvoie à la dominance dans les cas de secret de dominance où le pourcentage de dominance est nécessaire, néanmoins étant donné notre utilisation de Tau-Argus (pose du secret primaire “manuellement”) cette colonne ne nous intéresse pas.",
    "crumbs": [
      "En pratique",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Présentation des outils</span>"
    ]
  },
  {
    "objectID": "chapters/annexes/regles.html",
    "href": "chapters/annexes/regles.html",
    "title": "7  Règles",
    "section": "",
    "text": "7.1 Règles pour la statistique d’entreprises\nRègle de fréquence : une cellule d’un tableau ne doit pas être construite à partir de strictement moins de 3 unités. N.B. pour les bases de données pondérées on applique la règle de fréquence sur les pondérations. Si une cellule est construite par 2 répondants mais en représente davantage, alors elle est diffusable. Il faut veiller à ce que l’échantillon et la pondération restent confidentiels.\nRègle de dominance : 1 unité contributrice à une cellule ne peut contribuer à plus de 85% de la valeur de celle-ci. Afin, de pouvoir appliquer cette règle il faut donc déterminer pour chaque cellule du tableau le plus gros contributeur. N.B. pour les bases de données pondérées la cellule est sensible si le contributeur maximal (non pondérée) est supérieur à 85% du total de la cellule (pondéré). \\(MAX_{nonpond} &gt; 0.85*FREQ_{pond}\\)",
    "crumbs": [
      "Annexes",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Règles</span>"
    ]
  },
  {
    "objectID": "chapters/annexes/regles.html#règles-pour-les-données-fiscales-provenant-de-la-dgfip",
    "href": "chapters/annexes/regles.html#règles-pour-les-données-fiscales-provenant-de-la-dgfip",
    "title": "11  Règles",
    "section": "11.2 Règles pour les données fiscales (provenant de la DGFiP)",
    "text": "11.2 Règles pour les données fiscales (provenant de la DGFiP)\nRègle de fréquence : une cellule concernant une personne physique concernant moins de 11 unités ne doit pas être diffusée. Ce seuil est appliqué en particulier aux données se rapportant aux entreprises individuelles. Voici quelques exemples de données concernées par ce seuil :\n\ndonnées relatives à l’impôt sur le revenu (IR)\ndonnées relatives aux bénéfices industriels et commerciaux, aux bénéfices non commerciaux, aux bénéfices agricoles, à la taxe sur la valeur ajoutée, à la cotisation foncière des entreprises (CFE), à la cotisation sur la valeur ajoutée des entreprises (CVAE)\ndonnées relatives à tout autre type d’imposition dès lors que ces données se rapportent à des personnes physiques\n\nEn matière d’impôt de solidarité sur la fortune et d’impôt sur la fortune immobilière, les règles de communication sont les suivantes :\n\nle nombre de contribuables assujettis doit être supérieur ou égal à 50 ;\nen cas de ventilation par communes, celles-ci doivent comporter plus de 20 000 habitants\n\nRègle de dominance : 1 unité contributrice à une cellule ne peut contribuer à plus de 85% de la valeur de celle-ci. Afin, de pouvoir appliquer cette règle il faut donc déterminer pour chaque cellule du tableau le plus gros contributeur. N.B. pour les bases de données pondérées la cellule est sensible sur le contributeur maximal (non pondérée) est supérieur à 85% du total de la cellule (pondéré). \\(MAX_{nonpond} &gt; 0.85*FREQ_{pond}\\)"
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html",
    "href": "chapters/annexes/manipuler_les_listes.html",
    "title": "8  Manipuler les listes avec R",
    "section": "",
    "text": "8.1 Manipulations de base: créer, ajouter, supprimer\nPour accéder aux éléments d’une liste, il faut distinguer deux types d’indexation:\nliste_1[1]\n\n[[1]]\n[1] 1 2 3\n\nclass(liste_1[1])\n\n[1] \"list\"\n\nliste_1[[1]]\n\n[1] 1 2 3\n\nclass(liste_1[[1]])\n\n[1] \"integer\"\nPour ajouter un élément à une liste, plusieurs techniques sont possibles:\n(liste_2 &lt;- list(LETTERS, head(mtcars)))\n\n[[1]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[2]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n(liste_3 &lt;- c(liste_1, liste_2))\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"spam\" \"egg\" \n\n[[3]]\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\n[[4]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[5]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nlength(liste_3)\n\n[1] 5\nliste_3[6] &lt;- pi\nlength(liste_3)\n\n[1] 6\nSi on ajoute un élément à un index supérieur à la longueur de la liste + 1, R va créer automatiquement des éléments vides (de type NULL) sur les index “oubliés”. Ici, notre liste_3 contient 6 objets, si j’ajoute un élément à l’index 9, la liste aura une longueur de 9 avec deux objets NULL en positions 7 et 8:\nliste_3[9] &lt;- pi^2\nlength(liste_3)\n\n[1] 9\n\nliste_3[7:8]\n\n[[1]]\nNULL\n\n[[2]]\nNULL",
    "crumbs": [
      "Annexes",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipuler les listes avec `R`</span>"
    ]
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#manipulations-de-base-créer-ajouter-supprimer",
    "href": "chapters/annexes/manipuler_les_listes.html#manipulations-de-base-créer-ajouter-supprimer",
    "title": "12  Manipuler les listes avec R",
    "section": "12.1 Manipulations de base: créer, ajouter, supprimer",
    "text": "12.1 Manipulations de base: créer, ajouter, supprimer\nPour accéder aux éléments d’une liste, il faut distinguer deux types d’indexation:\n\navec les crochets simples: liste_1[1] va permettre de récupérer la liste composée uniquement du premier objet. Cette indexation renvoie une liste. On utilisera ce type d’indexation pour extraire une sous-liste d’une liste: liste_1[2:3] permet, par exemple, d’extraire la sous-liste composée des éléments 2 et 3 de la liste.\navec les crochets doubles: liste_1[[1]] permet d’accéder au premier élément de la liste. Le type de l’objet renvoyé est le type de l’objet placé dans la liste à l’index renseigné (dans notre cas un vecteur d’entiers). On utilisera cette indexation pour extraire un objet particulier de la liste.\n\n\nliste_1[1]\n\n[[1]]\n[1] 1 2 3\n\nclass(liste_1[1])\n\n[1] \"list\"\n\nliste_1[[1]]\n\n[1] 1 2 3\n\nclass(liste_1[[1]])\n\n[1] \"integer\"\n\n\nPour ajouter un élément à une liste, plusieurs techniques sont possibles:\n\najouter une liste à une autre liste avec la fonction c():\n\n\n(liste_2 &lt;- list(LETTERS, head(mtcars)))\n\n[[1]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[2]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n(liste_3 &lt;- c(liste_1, liste_2))\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"spam\" \"egg\" \n\n[[3]]\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\n[[4]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[5]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nlength(liste_3)\n\n[1] 5\n\n\n\najouter un élément avec l’indexation simple:\n\n\nliste_3[6] &lt;- pi\nlength(liste_3)\n\n[1] 6\n\n\nSi on ajoute un élément à un index supérieur à la longueur de la liste + 1, R va créer automatiquement des éléments vides (de type NULL) sur les index “oubliés”. Ici, notre liste_3 contient 6 objets, si j’ajoute un élément à l’index 9, la liste aura une longueur de 9 avec deux objets NULL en positions 7 et 8:\n\nliste_3[9] &lt;- pi^2\nlength(liste_3)\n\n[1] 9\n\nliste_3[7:8]\n\n[[1]]\nNULL\n\n[[2]]\nNULL"
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#nommer-les-éléments-dune-liste",
    "href": "chapters/annexes/manipuler_les_listes.html#nommer-les-éléments-dune-liste",
    "title": "12  Manipuler les listes avec R",
    "section": "12.2 Nommer les éléments d’une liste",
    "text": "12.2 Nommer les éléments d’une liste\nIl est souvent pratique de donner des noms à chaque élément de la liste. Cela permet de récupérer les objets sans avoir à connaître leur position dans la liste. La fonction names() permet d’accoler un nom à chaque élément de la liste. On fera bien attention à fournir un vecteur de noms qui soit de la même longueur que la liste.\n\nnames(liste_1) &lt;- c(\"vec_int\", \"vec_char\", \"cars_df\")\nnames(liste_1)\n\n[1] \"vec_int\"  \"vec_char\" \"cars_df\" \n\nliste_1\n\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n\n$cars_df\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\n\nPour récupérer un élément de la liste grçace à son nom, on pourra utiliser les deux types d’indexation vues ci-dessus en utilisant non pas les index de position dans la liste mais les noms des objets.\nPour récupérer une sous-liste, on fera:\n\nliste_1[\"vec_char\"] # retourne une sous-liste d'un élément\n\n$vec_char\n[1] \"spam\" \"egg\" \n\nliste_1[c(\"vec_int\", \"vec_char\")] # retourne une sous-liste de deux éléments\n\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n\n\nPour retourner un objet de la liste, on fera:\n\nliste_1[[\"vec_char\"]] # retourne l'élément vec_char en tant que vecteur\n\n[1] \"spam\" \"egg\" \n\n\nL’accès à un objet d’une liste est aussi possible en utilisant le $. Ainsi, l’écriture suivante est identique à la précédente:\n\nliste_1$vec_char\n\n[1] \"spam\" \"egg\" \n\n\nOn pourra nommer les éléments d’une liste au moment de la créer:\n\nliste_df &lt;- list(\n  df1 = cars,\n  df2 = mtcars,\n  df3 = iris,\n  df4 = CO2\n)\nnames(liste_df)\n\n[1] \"df1\" \"df2\" \"df3\" \"df4\""
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#supprimer-un-élément-dune-liste",
    "href": "chapters/annexes/manipuler_les_listes.html#supprimer-un-élément-dune-liste",
    "title": "12  Manipuler les listes avec R",
    "section": "12.3 Supprimer un élément d’une liste",
    "text": "12.3 Supprimer un élément d’une liste\nOn utilisera le code suivant pour supprimer le troisième élément d’une liste:\n\nliste_1[-3]\n\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n\n\nEt le code suivant pour supprimer les éléments 7 et 8 de liste_3\n\nlength(liste_3[c(-7,-8)])\n\n[1] 7"
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#appliquer-une-fonction-à-chaque-élément-une-liste-avec-la-fonction-lapply",
    "href": "chapters/annexes/manipuler_les_listes.html#appliquer-une-fonction-à-chaque-élément-une-liste-avec-la-fonction-lapply",
    "title": "12  Manipuler les listes avec R",
    "section": "12.4 Appliquer une fonction à chaque élément une liste avec la fonction lapply()",
    "text": "12.4 Appliquer une fonction à chaque élément une liste avec la fonction lapply()\nPour cette section, nous utiliserons principalement des listes dont tous les éléments sont du même type, en particulier des data.frames.\nPour appliquer une même fonction à tous les éléments d’une liste, il n’est pas besoin d’écrire une boucle for car la fonction lapply() s’en charge pour nous.\nUn premier exemple: Nous souhaitons connaître les dimensions de chaque data.frame qui compose la liste liste_df. Le premier argument de lapply est la liste sur laquelle nous travaillons et le second argument est la fonction que nous voulons appliquer sur chaque élément. Il s’agit, ici, de la fonction dim().\n\nlapply(liste_df, dim)\n\n$df1\n[1] 50  2\n\n$df2\n[1] 32 11\n\n$df3\n[1] 150   5\n\n$df4\n[1] 84  5\n\n\nLa fonction lapply() retourne une liste de même longueur que la liste de départ et chaque élément de la liste contient le résultat de la fonction dim() soit un vecteur de deux éléments (nombre de lignes et nombre de colonnes d’un data.frame).\nSecond exemple: Nous souhaitons afficher les deux premières lignes de chaque data.frame. Ici, nous allons utiliser la fonction head() qui affiche, par défaut les 6 premières lignes. Il nous faut donc changer un paramètre de la fonction. Nous pouvons:\n\nsoit créer une fonction anonyme (lambda):\n\n\nlapply(liste_df, function(df) head(df, n = 2))\n\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n\nlapply(liste_df, \\(df) head(df, n = 2)) # écriture de fonction apparue avec R 4.2\n\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n\n\nDans cette écriture df prendra successivement comme valeur les objets de la liste, comme le i dans une boucle for(i in ...).\n\nsoit contracter l’écriture (c’est possible ici car nous ne modifions pas l’objet df) de la manière suivante:\n\n\nlapply(liste_df, head, n = 2)\n\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n\n\nTroisième exemple: Nous souhaitons, dans chacun des tableaux, ajouter une variable servant d’identifiant.\n\nliste_df2 &lt;- lapply(\n  liste_df, \n  function(df){\n    df$index &lt;- 1:nrow(df)\n    return(df)\n  }\n)\nlapply(liste_df2, head, n=2)\n\n$df1\n  speed dist index\n1     4    2     1\n2     4   10     2\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb index\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4     1\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4     2\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species index\n1          5.1         3.5          1.4         0.2  setosa     1\n2          4.9         3.0          1.4         0.2  setosa     2\n\n$df4\n  Plant   Type  Treatment conc uptake index\n1   Qn1 Quebec nonchilled   95   16.0     1\n2   Qn1 Quebec nonchilled  175   30.4     2"
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#appliquer-une-fonction-à-chaque-élément-une-liste-avec-la-fonction-purrrmap",
    "href": "chapters/annexes/manipuler_les_listes.html#appliquer-une-fonction-à-chaque-élément-une-liste-avec-la-fonction-purrrmap",
    "title": "12  Manipuler les listes avec R",
    "section": "12.5 Appliquer une fonction à chaque élément une liste avec la fonction purrr::map()",
    "text": "12.5 Appliquer une fonction à chaque élément une liste avec la fonction purrr::map()\nLa package purrr met à disposition des fonctions qui permettent de manipuler les listes. Une aide précieuse pour découvrir tous les trésors du package est fournie ici: \n\nlibrary(purrr)\n\nWarning: le package 'purrr' a été compilé avec la version R 4.3.2\n\n\n\nLa fonction map() est un équivalent de la fonction lapply():\n\n\nmap(liste_df, dim)\n\n$df1\n[1] 50  2\n\n$df2\n[1] 32 11\n\n$df3\n[1] 150   5\n\n$df4\n[1] 84  5\n\n\nL’avantage du package est de fournir des variantes très utiles de la fonction map(), en particulier la fonction imap() qui permet d’accéder non pas seulement à tous les éléments de la liste mais aussi à leur index ou à leur nom.\nPar exemple, imaginons que nous souhaitons ajouter à chaque data.frame de la liste liste_df une variable contenant le nom du tableau. Avec la fonction imap() cela s’écrit:\n\nliste_df &lt;- imap(liste_df, \\(df, nom) df %&gt;% mutate(tableau = nom))\nmap(liste_df, head, n = 2)\n\n$df1\n  speed dist tableau\n1     4    2     df1\n2     4   10     df1\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb tableau\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4     df2\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4     df2\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species tableau\n1          5.1         3.5          1.4         0.2  setosa     df3\n2          4.9         3.0          1.4         0.2  setosa     df3\n\n$df4\n  Plant   Type  Treatment conc uptake tableau\n1   Qn1 Quebec nonchilled   95   16.0     df4\n2   Qn1 Quebec nonchilled  175   30.4     df4\n\n\nAvec imap(), la fonction anonyme n’a plus un mais deux arguments: l’un (que nous appelons df ici) représente chaque objet de la liste et l’autre (nommé nom ici) représente le nom de chaque élément. Ainsi, pour le premier élément, df prendra la valeur liste_df[[1]] et nom prendra la valeur df1."
  },
  {
    "objectID": "chapters/annexes/manipuler_les_listes.html#poser-le-secret-primaire-sur-une-liste-de-data.frames",
    "href": "chapters/annexes/manipuler_les_listes.html#poser-le-secret-primaire-sur-une-liste-de-data.frames",
    "title": "12  Manipuler les listes avec R",
    "section": "12.6 Poser le secret primaire sur une liste de data.frames",
    "text": "12.6 Poser le secret primaire sur une liste de data.frames\nL’utilisation des listes est nécessaire pour utiliser la fonction tab_muli_manager de rtauargus. Mais, elle est aussi intéressante en amont, par exemple dans la pose du secret primaire comme dans l’exemple fourni à la section ?sec-pose-secret-primaire.\n\nliste_4tabs &lt;- liste_4tabs %&gt;%\n  map(\n    function(df){\n      df %&gt;%\n        mutate(\n          is_secret_freq = N_OBS &gt; 0 & N_OBS &lt; 3,\n          is_secret_dom = (MAX != 0) & (MAX &gt; TOT*0.85),\n          is_secret_prim = is_secret_freq | is_secret_dom\n        )\n    }\n  )\n\nLe code ci-dessus permet d’appliquer à chacun des 4 data.frames qui composent la liste liste_4tabs une fonction anonyme qui:\n\nconstruit la variable is_secret_freq, permettant d’indiquer si une cellule respecte ou non la règle de fréquence (avec les règles des statistiques entreprises);\nconstruit la variable is_secret_dom, permettant d’indiquer si une cellule respecte ou non la règle de dominance;\nconstruit la variable is_secret_prim, permettant d’indiquer si une cellule respecte ou non les deux règles à la fois.\n\nEn sortie, nous obtiendrons ainsi une liste composés des mêmes 4 data.frames qui auront chacun les trois variables de secret primaire construites ici en plus."
  },
  {
    "objectID": "chapters/fiches_pratiques/var_hierarchique_nonemboitee.html",
    "href": "chapters/fiches_pratiques/var_hierarchique_nonemboitee.html",
    "title": "8  Poser le secret en présence de hiérarchies non-emboîtées",
    "section": "",
    "text": "Niveau moyen\n\n\nLorsque l’on a la présence de hiérarchie non-emboîtée dans les tableaux traités alors il faut construire deux tableaux et deux hiérarchies pour chaque hiérarchie non-emboîtée.\nPar exemple, le tableau turnover_act_size croise la NAF et les tranches d’effectifs des entreprises. Si l’on décide de publier, en plus des activités classiques de la NAF, un agrégat supplémentaire \\(AGREG = AZ + B\\), alors il faut construire un tableau supplémentaire avec cet agrégat. En effet, AGREG ne peut pas s’insérer dans la hiérarchie NAF, il faut donc construire deux hiérarchies :\n\nla hiérarchie NAF (principale)\nla hiérarchie de l’agrégat supplémentaire (alternative)\n\nOn crée le fichier .hrc de la hiérarchie principale à partir de la table de correspondance incluse dans le package.\n\nstr(activity_corr_table)\n\n'data.frame':   92 obs. of  3 variables:\n $ A10: chr  \"AZ\" \"AZ\" \"AZ\" \"BE\" ...\n $ A21: chr  \"A\" \"A\" \"X\" \"B\" ...\n $ A88: chr  \"01\" \"02\" \"X\" \"06\" ...\n\n\n\nwrite_hrc2(activity_corr_table, file_name = \"hrc/NAF_principale.hrc\")\n\nPuis on crée la hiérarchie alternative pour l’agrégat spécifique\n\nalt_corr_table &lt;- tibble::tibble(\n  niv0 = \"AGREG\",\n  niv1 = c(\"B\",\"AZ\")\n)\n\nwrite_hrc2(alt_corr_table %&gt;% select(-niv0), file_name = \"hrc/AGREG_alt.hrc\")\n\nOn construit les tableaux nécessaires à la pose du secret et on leur applique le secret primaire. A savoir le tableau sur lequel la hiérarchie principale sera appliquée.\n\nturnover_act_size_detect &lt;-  turnover_act_size %&gt;%\n  rename(FREQ = N_OBS, VALUE = TOT) %&gt;% \n  mutate(\n    is_secret_freq = FREQ &gt; 0 & FREQ &lt; 3,\n    is_secret_dom = (VALUE != 0) & (MAX &gt; 0.85*VALUE)\n  ) %&gt;% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\nEt le tableau sur lequel la hiérarchie alternative sera appliquée, i.e. tableau uniquement avec les modalités présentes dans la hiérarchie alternative et on pose le secret primaire.\n\ntrunover_act_size_alt &lt;- turnover_act_size_detect %&gt;% \n  filter(ACTIVITY %in% c(\"AZ\",\"B\"))\n\n\n\n\n\n\n\nArguments tab_multi_manager() pour traiter les hiérarchies non-emboîtées\n\n\n\n\nalt_totcode : une liste nommée pour les codes de totaux alternatifs (voir alt_hrc pour l’utilisation).\nalt_hrc : une liste nommée utile pour traiter les hiérarchies non emboîtées. Les noms de la liste sont les noms des tableaux pour lesquelles une autre hiérarchie (non emboîtée en général) doit être utilisée (ex : si T1 et T2 ont une variable explicative, appelée ACTIVITY, et la même variable de réponse, mais la variable ACTIVITY n’a pas la même hiérarchie dans les les deux tables). Supposons que les hiérarchies (act1.hrc et act2.hrc) ne sont pas emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit :\nhrc = c(ACTIVITY = \"chemin_vers_fichier/act_1.hrc\") : par défaut, cette hiérarchie sera utilisée pour la variable ACTIVITY.\nalt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\")) dans la table T2, la hiérarchie alternative sera utilisée.\n\n\n\n\nmasq_nonemb &lt;- tab_multi_manager(\n  list_tables = list(\n    tab = turnover_act_size_detect,\n    tab_alt = trunover_act_size_alt\n  ),\n  list_explanatory_vars = list(\n    tab = c(\"ACTIVITY\",\"SIZE\"),\n    tab_alt = c(\"ACTIVITY\",\"SIZE\")\n  ),\n  dir_name = \"tauargus_files/hrc_nonemb\",\n  hrc = list(ACTIVITY = \"hrc/NAF_principale.hrc\"),\n  alt_hrc = list(\n    tab_alt = c(ACTIVITY = \"hrc/AGREG_alt.hrc\")\n  ),\n  totcode = \"Total\",\n  alt_totcode = list(\n    tab_alt = c(ACTIVITY = \"AGREG\")\n  ),\n  value = \"VALUE\",\n  freq = \"FREQ\",\n  secret_var = \"is_secret_prim\"\n)\n\n\nmasq_nonemb &lt;- masq_nonemb %&gt;% \n  purrr::map(\n    function(tab){\n      tab %&gt;% \n        rename_with(~\"is_secret_final\", last_col()) %&gt;% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_dom ~ \"B\",\n            is_secret_final ~ \"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_nonemb)\n\nList of 2\n $ tab    :'data.frame':    414 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ FREQ           : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ VALUE          : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ tab_alt:'data.frame':    6 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:6] \"AZ\" \"AZ\" \"AZ\" \"B\" ...\n  ..$ SIZE           : chr [1:6] \"Total\" \"tr1\" \"tr2\" \"Total\" ...\n  ..$ FREQ           : int [1:6] 405 399 6 91 75 16\n  ..$ VALUE          : num [1:6] 44475 36356 8120 1171962 1051660 ...\n  ..$ MAX            : num [1:6] 6212 6212 4812 990201 990201 ...\n  ..$ is_secret_freq : logi [1:6] FALSE FALSE FALSE FALSE FALSE FALSE\n  ..$ is_secret_dom  : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_prim : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_1    : logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ is_secret_final: logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ statut_final   : chr [1:6] \"V\" \"V\" \"V\" \"V\" ...\n\n\nOn peut dresser le bilan :\n\nmasq_nonemb %&gt;% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %&gt;% \n        count(statut_final) %&gt;% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %&gt;% \n        relocate(table)\n    }\n  )\n\n    table statut_final   n      part\n1     tab            A  52 12.560386\n2     tab            B  25  6.038647\n3     tab            D  78 18.840580\n4     tab            V 259 62.560386\n5 tab_alt            B   1 16.666667\n6 tab_alt            D   1 16.666667\n7 tab_alt            V   4 66.666667"
  },
  {
    "objectID": "chapters/fiches_pratiques/introduction.html#structure-des-données",
    "href": "chapters/fiches_pratiques/introduction.html#structure-des-données",
    "title": "5  Introduction",
    "section": "5.1 Structure des données",
    "text": "5.1 Structure des données\nTous les tableaux fournis en entrée de rtauargus ont une structure identique :\n\nLes variables décrivant les croisements (variables catégorielles) sont placées au début\nFREQ la variable indiquant le nombre d’unités statistiques contribuant à la cellule;\nVALUE la variable indiquant la somme pondérée des valeurs de l’ensemble des contributeurs à la cellule (ex : un chiffre d’affaires, un nombre de personnes en emploi au 31/12, etc.);\nMAX la valeur du plus gros contributeur à la cellule.\n\nN.B : pour les tableaux de fréquence FREQ = VALUE."
  },
  {
    "objectID": "chapters/fiches_pratiques/tabulate_micro_data.html#tabulate_micro_data",
    "href": "chapters/fiches_pratiques/tabulate_micro_data.html#tabulate_micro_data",
    "title": "6  Préparation des tableaux pour la pose du secret",
    "section": "6.1 tabulate_micro_data()",
    "text": "6.1 tabulate_micro_data()\n\n6.1.1 Présentation\nPour la pose du secret, outre la valeur des cellules (que l’on nommera VALUE), il est nécessaire d’avoir des informations supplémentaires par rapport au tableau publié :\n\nFREQ : Le nombre d’unités statistiques ayant contribué à la cellule (pour déterminer le secret primaire de fréquence).\nMAX : La valeur du plus gros contributeur de la cellule (pour déterminer le secret primaire de dominance)\nles sous-totaux pour toutes les combinaisons possibles entre les variables. Par exemple, pour un tableau à 3 variables (A10 x SIZE x CJ)\n\n\n\n\nA10\nSIZE\nCJ\n\n\n\n\nTotal\nTotal\nTotal\n\n\nTotal\nTotal\n*\n\n\nTotal\n*\nTotal\n\n\n*\nTotal\nTotal\n\n\nTotal\n*\n*\n\n\n*\nTotal\n*\n\n\n*\n*\nTotal\n\n\n\nIl est possible de générer ce tableau soi-même. Mais pour faciliter la préparation de ces informations, le package rtauargus contient la fonction tabulate_micro_data pour le générer.\n\n\n6.1.2 arguments\n\ndf : jeu de données individuelles (data.frame ou data.table)\ncat_vars : Variables de croisements (catégorielles) non hiérarchiques (vecteur)\nhrc_vars : Variables de croisements hiérarchiques sous la forme d’une liste nommée\npond_var : Variable de pondération\nresp_var : Indicateur(s), variable(s) de réponse\nmarge_label : Label utilisé pour les marges (sous-totaux)\n\n\n\n6.1.3 résultat\n\nnb_obs : Comptage du nombre d’unités statistiques (FREQ)\nX_tot : Indicateur / variable de réponse (VALUE)\nX_max : Contribution maximale (MAX)."
  },
  {
    "objectID": "chapters/fiches_pratiques/tabulate_micro_data.html#exemples",
    "href": "chapters/fiches_pratiques/tabulate_micro_data.html#exemples",
    "title": "6  Préparation des tableaux pour la pose du secret",
    "section": "6.2 Exemples",
    "text": "6.2 Exemples\n\n6.2.1 Appel simple\nTrois variables de croisement (“A10”, “SIZE”, “CJ”) et une variable de réponse (“PRODUCTION”).\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n\n6.2.2 Variable de réponse pondérée\nDans le cas d’enquêtes non exhaustives, les observations sont pondérées. Pour indiquer la colonne de pondération, utiliser l’argument pond_var.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\", \"WEIGHT\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , pond_var = \"WEIGHT\"\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n\n6.2.3 Variable hiérarchique\nDans le cas de variables hiérarchiques (cf § 4.4), il faut utiliser l’argument hrc_vars.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\",\"A21\",\"A88\", \"SIZE\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"SIZE\")\n                                         , resp_var = \"PRODUCTION\"\n                                         , hrc_vars = list(ACTIVITY = c(\"A10\",\"A21\",\"A88\"))\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n\n6.2.4 Deux indicateurs en même temps\nSi plusieurs tableaux, portant sur des variables d’intéret différentes mais ont les mêmes variables de croisement, il est possible de préparer les tableaux de secret en un seul appel à tabulate_micro_data, en fournissant un vecteur à l’argument resp_var.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"SIZE\", \"CJ\", \"TURNOVER\", \"PRODUCTION\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(indiv_dt\n                                         , cat_vars = c(\"SIZE\", \"CJ\")\n                                         , resp_var = c(\"TURNOVER\", \"PRODUCTION\")\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)\n\n\n\n\n\n\n\n\n6.2.5 Tableaux de fréquence\nLes tableaux publiés sont souvent des tableaux de comptage. Par exemple, combien combien d’entreprises ont pour code NAF X. Ces tableaux sont un cas particulier. Leur VALUE est identique à leur FREQ et leur MAX n’a pas de signification. Lors de l’appel à la fonction tabulate_micro_data, on ne fournit pas de variable de réponse et la fonction ne retourne que le comptage.\n\ndata(indiv_dt)\ndtDonneesMicro &lt;- indiv_dt[, c(\"A10\", \"SIZE\", \"CJ\")]\n\nDT::datatable(dtDonneesMicro)\n\n\n\n\n\ndtDonneesTabulees &lt;- tabulate_micro_data(dtDonneesMicro\n                                         , cat_vars = c(\"A10\", \"SIZE\", \"CJ\")\n                                         , marge_label = \"Total\")\nDT::datatable(dtDonneesTabulees)"
  },
  {
    "objectID": "chapters/fiches_pratiques/var_hierarchique.html#première-option",
    "href": "chapters/fiches_pratiques/var_hierarchique.html#première-option",
    "title": "7  Prendre en compte une variable hiérarchique",
    "section": "7.1 Première option",
    "text": "7.1 Première option\nLa première option consiste à créer le fichier nécessaire (extension .hrc) à la main. Ceci est tout à fait pertinent si la hiérarchie n’est pas trop étendue.\nTau-Argus attend en effet un type de fichier bien particulier, dont l’extension est .hrc. Il s’agit d’un simple fichier texte où les différents emboîtements sont écrits les uns en-dessous des autres. Un symbole (le @) est utilisé pour préciser le niveau de chacun des emboîtements au sein de la hiérarchie.\nDans notre exemple on écrirait le fichier de la façon suivante :\n\nNord\n@N1\n@N2\n@N3 \nOuest \n@O1 \n@O2 \n@O3 \n@O4 \nEst\n@E1 \n@E2 \n@E3 \nSud \n@S1 \n@S2\n\nOn remarque que le total Pays n’est pas inclus dans le fichier .hrc c’est parce qu’il ne faut pas indiquer le super-total de la hiérarchie à Tau-Argus."
  },
  {
    "objectID": "chapters/fiches_pratiques/var_hierarchique.html#seconde-option",
    "href": "chapters/fiches_pratiques/var_hierarchique.html#seconde-option",
    "title": "7  Prendre en compte une variable hiérarchique",
    "section": "7.2 Seconde option",
    "text": "7.2 Seconde option\nQuand la hiérarchie est très étendue, l’écriture manuelle du fichier de hiérarchie est pénible. Or, quand ce genre de cas se présente, il existe souvent une table de correspondance permettant d’associer les différents niveaux entre eux.\nNous appelons table de correspondance une table qui précise l’ensemble des niveaux associés aux emboîtements les plus fins.\nLa table de correspondance représentant la hiérarchie ci-dessus est la suivante:\n\npays_corr_table &lt;- tibble(\n  niv0 = \"Pays\",\n  niv1 = c(rep(\"Nord\",3),rep(\"Ouest\",4),rep(\"Est\",3), rep(\"Sud\",2)),\n  niv2 = c(paste0(\"N\",1:3),paste0(\"O\",1:4),paste0(\"E\",1:3), paste0(\"S\",1:2))\n)\npays_corr_table\n\n# A tibble: 12 × 3\n   niv0  niv1  niv2 \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 Pays  Nord  N1   \n 2 Pays  Nord  N2   \n 3 Pays  Nord  N3   \n 4 Pays  Ouest O1   \n 5 Pays  Ouest O2   \n 6 Pays  Ouest O3   \n 7 Pays  Ouest O4   \n 8 Pays  Est   E1   \n 9 Pays  Est   E2   \n10 Pays  Est   E3   \n11 Pays  Sud   S1   \n12 Pays  Sud   S2   \n\n\nAvec la fonction write_hrc2() du package rtauargus, on peut transformer la table de correspondance en un fichier hrc.\n\nwrite_hrc2(pays_corr_table %&gt;% select(-niv0), file_name = \"hrc/pays_TA_2.hrc\")\n\nRemarque: La fonction rtauargus::write_hrc2() n’accepte pas de valeurs manquantes dans la table en entrée. Lorsqu’une hiérarchie n’a pas la même nombre de sous-niveaux selon les branches on répète la modalité du niveau supérieur sur les niveaux inférieurs pour ne pas avoir de cases vides.\nExemple : pour la hiérarchie ci-dessous on répète la modalité C dans la table de correspondance.\n\n\n\n\nflowchart TD\nA[Total] --&gt; B[A]\nA --&gt; C[B]\nA --&gt; D[C]\nB --&gt; E[A1]\nB --&gt; F[A2]\nC --&gt; G[B1]\nC --&gt; H[B2]\nH --&gt; I[B21]\nH --&gt; J[B22]\n\n\n\n\n\n\ncorr_tab &lt;- tibble(\n  niv0 = \"ALL\",\n  niv1 = c(rep(\"A\",2),rep(\"B\",3), \"C\"),\n  niv2 = c(\"A1\",\"A2\",\"B1\",rep(\"B2\",2), \"C\"),\n  niv3 = c(\"A1\",\"A2\",\"B1\", \"B21\", \"B22\", \"C\")\n)\ncorr_tab\n\n# A tibble: 6 × 4\n  niv0  niv1  niv2  niv3 \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 ALL   A     A1    A1   \n2 ALL   A     A2    A2   \n3 ALL   B     B1    B1   \n4 ALL   B     B2    B21  \n5 ALL   B     B2    B22  \n6 ALL   C     C     C"
  },
  {
    "objectID": "chapters/fiches_pratiques/couts.html",
    "href": "chapters/fiches_pratiques/couts.html",
    "title": "9  Utiliser les coûts",
    "section": "",
    "text": "Niveau expert\n\n\n\n\n\n\nObjectif : apprendre à utiliser l’option cost du package rtauargus afin de rediriger le secret secondaire.\nTau-Argus utilise des algorithmes d’optimisation afin de minimiser la perte d’information qui résulte du secret secondaire. La question qui se pose est quelle valeur doit-être minimiser ? Plusieurs choix sont possibles, la valeur des cellules, le nombre de cellules, les effectifs des cellules. Il est également possible de personnaliser les coûts si l’on souhaite prioriser la pose de secret secondaire sur certains agrégats.\n\n9.0.1 Minimiser la valeur secrétisée\nTau-Argus minimise par défaut la valeur des cellules supprimées. C’est ce qui est le plus cohérent, lorsque l’on publie un tableau c’est bien la valeur des cellules qui nous intéresse.\n\n\n9.0.2 Minimiser le nombre de cellules secrétisées\nPour minimiser le nombre de cellules secrétisées il faut utiliser le paramètre cost et donc le définir dans notre table. si l’on souhaite minimiser le nombre de cellules masquées, il faut alors que le coût de suppression de chaque cellule soit identique, Tau-Argus considère alors qu’elles ont toutes la même importance. Pour cela il faut créer une colonne “cost” qui vaut 1 pour toutes les cellules de notre tableau.\n\n\n9.0.3 Minimiser les effectifs secrétisés\nOn peut aussi considérer que la valeur importante des cellules sont leurs effectifs. On peut penser qu’un nombre de répondants élevé pour une cellule lui confère une plus grande fiabilité statistique. Pour cela il suffit simplement de recopier la colonne “freq” dans notre colonne “cost”.\n\n\n9.0.4 Orienter le secret secondaire\nDans certaines données on peut trouver des agrégats jugés non significatifs. Ces derniers ne seront pas publiés dans les tableaux mais notés “ns”. On peut alors s’en servir pour la pose du secret secondaire.\nAttention, on pourrait penser que ces cellules devraient être placées en secret primaire, afin qu’elles soient considérées comme masquées quoi qu’il arrive. Cependant, cela peut entraîner plus de secret secondaire que nécessaire sachant qu’il n’est pas nécessaire de protéger ces cellules du risque de recoupement. L’utilisateur peut retrouver la valeur de ces cellules, mais il est averti qu’elles n’ont aucune importance statistique.\nPour prioriser le secret secondaire on crée donc pour les agrégats non-significatifs la colonne “cost” qui vaut 1. C’est le coût minimal, ceci indiquera à Tau-Argus que ces agrégats sont donc prioritaires pour le secret secondaire. Ainsi, certains coûts ne seront pas définis. Ce n’est pas un problème, lorsque l’on ne spécifie pas de coût pour une cellule, Tau-Argus va considérer que son coût de suppression est égal à la valeur de cette dernière.\nExemple\nSi par exemple, on souhaite prioriser le secret sur la tranche d’effectif 1 tr1 dans turnover_act_size, tableau intégré à rtauargus.\nTout d’abord, on pose le secret primaire sur le tableau.\n\ndata(\"turnover_act_size\")\n\nturnover_act_size_detect &lt;-  turnover_act_size %&gt;%\n  rename(FREQ = N_OBS, VALUE = TOT) %&gt;% \n  mutate(\n    is_secret_freq = FREQ &gt; 0 & FREQ &lt; 3,\n    is_secret_dom = (VALUE != 0) & (MAX &gt; 0.85*VALUE)\n  ) %&gt;% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\nPuis, on assigne on assigne la valeur 1 pour le coût de tous les croisements avec tr1.\n\nturnover_act_size_ns &lt;- turnover_act_size_detect %&gt;%\n  mutate(cost = ifelse(SIZE == \"tr1\", 1, VALUE))\nstr(turnover_act_size_ns)\n\ntibble [414 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE          : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ          : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE         : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX           : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n $ is_secret_freq: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n\n\nOn vérifie que les coûts à 1 ont bien été appliqués.\n\nstr(turnover_act_size_ns %&gt;% filter(cost == 1))\n\ntibble [113 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:113] \"Total\" \"AZ\" \"BE\" \"FZ\" ...\n $ SIZE          : chr [1:113] \"tr1\" \"tr1\" \"tr1\" \"tr1\" ...\n $ FREQ          : int [1:113] 217053 399 11485 26937 59426 7884 8026 11850 39819 26291 ...\n $ VALUE         : num [1:113] 1.01e+08 3.64e+04 4.69e+06 4.55e+06 1.10e+07 ...\n $ MAX           : num [1:113] 10018017 6212 990201 225864 765244 ...\n $ is_secret_freq: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:113] 1 1 1 1 1 1 1 1 1 1 ...\n\n\nOn pose le secret secondaire à l’aide de la fonction tab_rtauargus().\n\nres_ns &lt;- tab_rtauargus(\n  turnover_act_size_ns,\n  files_name = \"couts\",\n  dir_name = \"tauargus_files/couts\",\n  explanatory_vars = c(\"ACTIVITY\",\"SIZE\"),\n  totcode = c(\"Total\",\"Total\"),\n  freq = \"FREQ\",\n  value = \"VALUE\",\n  secret_var = \"is_secret_prim\",\n  cost_var = \"cost\",\n  verbose = FALSE\n)\n\nOn peut ensuite créer une synthèse du secret posé.\n\nsynthese_ns &lt;- res_ns %&gt;% group_by(Status) %&gt;%\n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  ) %&gt;% \n  group_by(statut_final) %&gt;% \n  summarise(\n    nb_cellules = n(),\n    effectif = sum(FREQ),\n    valeur = sum(VALUE)\n  )\n\nsynthese_ns\n\n# A tibble: 4 × 4\n  statut_final nb_cellules effectif      valeur\n  &lt;chr&gt;              &lt;int&gt;    &lt;int&gt;       &lt;dbl&gt;\n1 A                     52       76   22115262.\n2 B                     25    15219   37823909.\n3 D                     46   115266  142992327.\n4 V                    291  1667583 1259310983."
  },
  {
    "objectID": "chapters/annexes/regles.html#règles-pour-la-statistique-dentreprises",
    "href": "chapters/annexes/regles.html#règles-pour-la-statistique-dentreprises",
    "title": "11  Règles",
    "section": "11.1 Règles pour la statistique d’entreprises",
    "text": "11.1 Règles pour la statistique d’entreprises\nRègle de fréquence : une cellule d’un tableau ne doit pas être construite à partir de strictement moins de 3 unités. N.B. pour les bases de données pondérées on applique la règle de fréquence sur les pondérations. Si une cellule est construite par 2 répondants mais en représente davantage, alors elle est diffusable. Il faut veiller à ce que l’échantillon et la pondération restent confidentiels.\nRègle de dominance : 1 unité contributrice à une cellule ne peut contribuer à plus de 85% de la valeur de celle-ci. Afin, de pouvoir appliquer cette règle il faut donc déterminer pour chaque cellule du tableau le plus gros contributeur. N.B. pour les bases de données pondérées la cellule est sensible si le contributeur maximal (non pondérée) est supérieur à 85% du total de la cellule (pondéré). \\(MAX_{nonpond} &gt; 0.85*FREQ_{pond}\\)"
  },
  {
    "objectID": "06_outils.html#tau-argus",
    "href": "06_outils.html#tau-argus",
    "title": "10  Présentation des outils",
    "section": "10.1 Tau-argus",
    "text": "10.1 Tau-argus\n\n10.1.1 Présentation générale\nTau-Argus est la logiciel de référence en Europe en termes de pose de secret. Il permet de calculer le secret primaire et secondaire ou de faire des arrondis contrôlés. Le développement, la maintenance et le support de Tau-Argus sont réalisés par un groupe d’experts européens et est coordonné par CBS (l’institut national de statistiques des Pays-Bas). C’est un logiciel libre et open source (https://github.com/sdcTools/tauargus) utilisable via une interface graphique.\n\n\n10.1.2 Les différents algorithmes du secret secondaire\nPlusieurs algorithmes sont implémentes dans Tau-Argus pour gérer le secret secondaire. La méthode Hypercube permet un traitement séquentiel des cases sous secret primaire, en minimisant le coût. Dans le cas d’une hiérarchie, elle traite les sous-tableaux indépendamment. Il s’agit d’une méthode heuristique et rapide. Elle a l’avantage de proposer un masque rapidement mais celui-ci n’est pas le plus optimal. La méthode Optimal met en place une minimisation globale du coût et respecte les intervalles de protection. C’est une méthode souvent très lente. Enfin, la méthode Modular éclate le problème en différents sous-tableaux sur lesquels elle applique la méthode Optimal. La méthode est plus efficace avec des variables hiérarchiques car elle se base sur celle-ci pour créer les sous-tableaux. C’est une méthode assez rapide que l’on utilise dans la plupart des cas.\n\n\n10.1.3 Avantages et inconvénients\nTau-Argus comporte de nombreux avantages, il s’agit d’un outil qui fait référence, performant sur la partie pose de secret et il est maintenu régulièrement. Cependant, il a des limites. En effet, l’interface est assez fouillis, il renvoie des bugs et des erreurs pas toujours facile à comprendre et corriger, enfin la reproductibilité des opérations est limitée."
  },
  {
    "objectID": "06_outils.html#package-rtauargus",
    "href": "06_outils.html#package-rtauargus",
    "title": "10  Présentation des outils",
    "section": "10.2 Package rtauargus",
    "text": "10.2 Package rtauargus\nBien que l’usage standard de Tau-Argus se fasse par une interface graphique, la prise en main n’est pas aisée. Ainsi, un package R a été développé à l’Insee pour travailler avec Tau-Argus depuis R : rtauargus. Il permet de bénéficier des avantages de Tau-Argus tout en limitant les inconvénients.\n\n10.2.1 Objectifs\nLe but de ce package est de faciliter la prise en main de Tau-Argus. Ainsi, il permet de poser le secret secondaire avec Tau-Argus sans l’ouvrir et gérer de grosses demandes.\n\n\n10.2.2 Principales fonctionnalités\nLe package a deux fonctionnalités principales : il permet de poser le secret directement sur les tableaux ou à partir des microdonnées. Le fonctionnement général du package est le suivant : création de l’ensemble des fichiers dans les formats attendus par Tau-Argus, lancement de Tau-Argus puis récupération des résultats dans R.\nLa démarche utilisée à la DMRG consiste à poser le secret primaire “manuellement”, c’est-à-dire sans faire appel à Tau-Argus et d’ensuite poser le secret secondaire à l’aide de la fonction tab_rtauargus() pour protéger un seul tableau et tab_multi_manager() pour protéger plusieurs tableaux.\n\n\n10.2.3 Où trouver la documentation ?\nLe documentation est disponible en ligne : https://inseefrlab.github.io/rtauargus/"
  },
  {
    "objectID": "06_outils.html#les-limites-de-tau-argus",
    "href": "06_outils.html#les-limites-de-tau-argus",
    "title": "10  Présentation des outils",
    "section": "10.3 Les limites de Tau-Argus",
    "text": "10.3 Les limites de Tau-Argus\n\n10.3.1 Le nombre de variables de ventilation\nActuellement \\(\\tau\\)-Argus tolère au maximum 4 variables de ventilation par tableau. Cependant, pour 4 variables de ventilation un warning apparaît, \\(\\tau\\)-Argus ne garantit pas une protection totale de la table. Effectuer un contrôle de cohérence sur le secret pour un tableau avec 4 dimensions est très complexe.\nPour pallier cette limitation, le package rtauargus permet de transformer des tableaux de 4 ou 5 dimensions en tableaux de 3 dimensions. Pour cela, il suffit de renseigner l’argument split_tab = TRUE lors de l’appel de tab_multi_manager() ou tab_rtauargus()\n\ndtMasque &lt;- tab_rtauargus(tabular = dtTableau\n              , explanatory_vars = c(\"NAF\", \"GEO\", \"CJ\", \"TREFF\", \"TRAGE\")\n              , files_name = \"tableauSecretise\"\n              , dir_name = \"c:/\"\n              , totcode = c(\"Total\", \"Total\", \"Total\", \"Total\", \"Total\")\n              , secret_var = \"is_secret_prim\"\n              , value = \"VALUE\"\n              , freq = \"FREQ\"\n              , maxscore = \"MAX\"\n              , split_tab = TRUE)\n\nPour aller plus loin, vous trouverez une vignette très complète sur le sujet dans le package rtauargus. (rtauargus/doc/split_tab_fr.html)\n\n\n10.3.2 Les valeurs trop élevées\n\\(\\tau\\)-Argus ne parvient pas à traiter un tableau s’il rencontre une cellule d’une valeur trop élevée.Dans le cas où une celulle du tableau viendrait à dépasser \\(10^{12}\\), un message d’erreur apparaîtra lors de la pose du secret secondaire. Afin d’éviter ce genre de problème, il est conseillé de regarder si le plus gros total du tableau dépasse \\(10^{12}\\), le cas échéant nous recommandons de diviser la valeur de votre tableau par une puissance de 10 adéquate. Cependant cela implique de faire attention à plusieurs choses :\n\nTraiter le secret primaire dans le fichier d’apriori avant d’arrondir les valeurs.\nS’assurer qu’aucune valeur n’est arrondie à 0, elle ne serait alors plus prise en compte lors du traitement du secret secondaire, dans ce cas il faut forcer un arrondi à 1 minimum.\nSi la valeur du plus gros contributeur est encore présente dans la table, l’arrondir avec le même ordre de grandeur que la variable de réponse.\n\nA ce jour, aucune limite n’a été constatée en terme de nombre de décimales, la piste reste à explorer. Mais nous recommandons tout de même d’arrondir les valeurs. Dans tous les cas les arrondis n’impacteront que très peu la pose du secret.\n\n\n10.3.3 Les limites du fichier hiérarchique\n\n10.3.3.1 Le nombre de caractère des feuilles\nAu sein d’un fichier .hrc, \\(\\tau\\)-Argus a besoin qu’au niveau hiérarchique le plus fin les feuilles aient le même nombre de caractères. Par exemple la hiérarchie suivante renverra un message d’erreur :\n\nA\n@A01\n@A02\n@A3\n\nLa fonction write_hrc2() permet d’ajouter des * dans la hiérarchie et les modalités du tableau afin d’éviter ce genre d’erreurs. Afin que ce soit le plus robuste possible cette transformation est appliquée à tous les niveaux hiérarchiques. Pour l’exemple précédent on obtiendra alors la hiérarchie :\n\n***A\n@A01\n@A02\n@*A3\n\n\n\n10.3.3.2 Les feuilles uniques\nNIVEAU EXPERT\nLors de la reconstitution des totaux de la table par \\(\\tau\\)-Argus, on obtient une erreur si la hiérarchie contient ce qu’on va appeler une “feuille unique”. Par exemple dans la hiérarchie :\n\nA\n@A1\n@@A11\n@@A12\n\nA1 sera ce qu’on appelle une feuille unique, c’est le seul sous-niveau de A. Ce problème n’est présent que lorsqu’on traite des données tabulées, la solution que nous utilisons actuellement est de créer une feuille fictive dans la hiérarchie. La gestion de ce cas-là est intégrée automatiquement dans le package, c’est pourquoi vous trouverez des fichiers suffixés unif ce sont les fichiers hrc renseignées par l’utilisateur sont modifiés pour traiter cela. La nouvelle hiérarchie sera la suivante :\n\nA\n@AX\n@A1\n@@A11\n@@A12\n\nIl n’y a pas besoin de modifier le tableau l’agrégat AX vaudra 0 et le traitement de la table s’effectuera correctement.\n\n\n\n10.3.4 Le nombre de modalités\nDans \\(\\tau\\)-Argus, le nombre de modalités au sein d’un même niveau hiérarchique est limité.\n\n10.3.4.1 Variable non hiérarhcique\nPour une variable non hiérarchique \\(\\tau\\)-Argus ne peut pas traiter plus de 199 modalités (200 en comptabilisant le Total). Par exemple, un tableau au niveau communal avec donc 35 000 communes ne pourra pas être traité directement via \\(\\tau\\)-Argus. Les solutions que nous conseillons actuellement sont :\n\nDe découper le tableau en divers sous-tableau afin de respecter ce nombre de modalités maximum.\nD’insérer une variables hiérarchique qui permettra de respecter les critères décrits ci-dessous. Cela implique de traiter les nouveaux niveaux hiérarchiques comme des variables non diffusées.\n\n\n\n10.3.4.2 Variable hiérarchique\nPour une variable hiérarchique il faut qu’il y ait moins de 200 modalités par niveau de la hiérarchie. Considérons la hiérarchie Région &gt; Département &gt; Commune, pour que \\(\\tau\\)-Argus puisse poser le secret secondaire :\n\nIl faut moins de 200 régions.\nDans une région donnée, il faut moins de 200 départements.\nDans un département donné, il faut moins de 200 communes.\n\nCependant, les zonages géographiques français ne respectent pas ces limites.\nDans notre exemple, dans chaque département il y a plus de 200 communes, le traitement hiérarchique tel quel est donc impossible. Une solution envisageable serait de rajouter un niveau hiérarchique en plus afin de réduire le nombre de commune sau même niveau. On peut penser ici par exemple aux cantons puisque qu’un département contient au maximum 43 cantons et un canton contient au maximum 135 communes. On pourrait alors traiter le hiérarchie Région &gt; Département &gt; Canton &gt; Commune. Les cellules concernant les cantons devront être traitées comme des cellules non diffusées et donc être prioritaires au niveau du secret secondaire. C’est-à-dire qu’à choisir on indiquera au programme de secrétiser plutôt un canton que tout autre zonage géographique\n\n\n\n10.3.5 Les algorithmes de secret secondaire\nDans certains cas assez particuliers, il se peut qu’un algorithme de secret secondaire ne puisse pas trouver de solution au problème en entrée. Étant donné que nous recommandons d’utiliser Modular en priorité, si jamais l’algorithme ne parvient pas à trouver de solution il faut alors tester Optimal puis HyperCube. Si aucun de ces trois algorithmes ne parvient à trouver de solution, cela vient généralement d’une grande table qui contient énormément de secret primaire. Dans ce cas nous recommandons de reconsidérer le problème. Cela vaut-il vraiment la peine de diffuser une table à un niveau aussi fin avec autant de secret primaire ? Il est peut être préférable d’agréger les données afin d’avoir moins de secret primaire."
  },
  {
    "objectID": "06_outils.html#les-codes-derreur-dans-tau-argus",
    "href": "06_outils.html#les-codes-derreur-dans-tau-argus",
    "title": "10  Présentation des outils",
    "section": "10.4 Les codes d’erreur dans Tau-Argus",
    "text": "10.4 Les codes d’erreur dans Tau-Argus\nCette partie n’est pas exhaustive mais recense les codes d’erreurs que nous avons rencontré en utilisant Tau-Argus.\nLes différentes causes possibles du message “code not in codelist” sont les suivantes :\n\nUne modalité d’une variable hiérarchique est présente dans la table mais pas dans le fichier hiérarchique associé\nLes noms de colonnes spécifiés pour le paramètre specify_tables de la fonction tab_arb() ne sont pas dans le même ordre que dans le tableau\n\nLe message d’erreur “illegal status in transition” est lié à l’apriori. Voici les différentes causes possibles :\n\nUne cellule possède deux status contradictoires dans le fichier d’apriori (ex : A01,s et A01,u). La cellule ne pouvant pas avoir deux status à la fois, Tau-Argus ne peut pas comprendre le statut de la cellule\nUne cellule avec une valeur nulle et un effectif nul est renseignée comme unsafe (u)\n\nLes différentes causes possibles du message d’erreur “error making totals” sont :\n\nOn a écrit dans le batch  et donc les totaux dans le tableau ne sont pas égaux à la somme des éléments qui le composent, autrement dit la table n’est pas additive\nOn écrit dans le batch  1 et donc Tau-Argus reconstitue lui-même les totaux. Cela vient généralement du problème des feuilles uniques décrit dans la partie précédente.\n\nLe message d’erreur “HiTaS: couldn’t load JJ-routines” est spécifique à l’aglorithme Modular, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (voir section 10.3.2)\nLe problème paraît insoluble pour Modular (voir sections 10.3.4 et 10.3.5)\nN.B : parfois “couldn’t load JJ-routines” (sans HiTaS devant) renvoie à un problème lié à la hiérarchie (sans doute impossibilité de reconstituter la hiérarhcie à partir des données en entrée)\n\nLe message d’erreur “no optimal solution found JJ not loaded” est spécifique à l’aglorithme Optimal, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (voir section 10.3.2)\nLe problème paraît insoluble pour Optimal (voir sections 10.3.4 et 10.3.5)\n\nLe message d’erreur “the hypercube could not be applied See file PROTO002” est spécifique à l’aglorithme HyperCube, en voici les différentes causes possibles :\n\nLa taille maximale pour un nombre à été dépassée (voir section 10.3.2)\nLe problème paraît insoluble pour HyperCube (voir sections 10.3.4)\n\nPour le message “error in modular suppression procedure” il faut bien faire attention que c’est le message d’erreur présent dans le batch :\n\nGénéralement quand c’est l’unique message d’erreur, alors c’est que Modular a tourné pendant quelques minutes puis a atteint une limite de mémoire dans Tau-Argus\nVoir 10.3.5 et tester avec un autre algorithme"
  },
  {
    "objectID": "06_outils.html#savoir-lire-les-différents-types-de-fichiers-spécifiques-à-tau-argus",
    "href": "06_outils.html#savoir-lire-les-différents-types-de-fichiers-spécifiques-à-tau-argus",
    "title": "10  Présentation des outils",
    "section": "10.5 Savoir lire les différents types de fichiers spécifiques à Tau-Argus",
    "text": "10.5 Savoir lire les différents types de fichiers spécifiques à Tau-Argus\nFichiers en sortie de rtauargus :\n\n.rda : fichier de métadonnées pour Tau-Argus\n.tab : fichier donné à Tau-Argus, il est décrit par .rda, les colonnes sont dans l’ordre des nom dans .rda\n.hst : fichier de l’apriori, avec rtauargus on pose le secret primaire en amont, on ne demande pas à Tau-Argus de le faire. Dans ce fichier on a à la fois le secret de départ, le “protection level” et les coûts (c)\n.arb : fichier executé dans la console windows, il est interprété par Tau-Argus. Autrement dit, ce sont une liste de commandes données à Tau-Argus\n\nFichiers en sortie de Tau-Argus :\n\n.txt : journal d’exécution, il n’écrase pas les exécutions ainsi on peut voir toutes les exécutions jamais faites avec Tau-Argus\n.csv : données d’entrée avec deux nouvelles colonnes. La colonne status à trois modalités : “B” = secret apriori (u), “D” = secret secondaire, “V” = cellules valides, diffusables. La colonne dom renvoie à la dominance dans les cas de secret de dominance où le pourcentage de dominance est nécessaire, néanmoins étant donné notre utilisation de Tau-Argus (pose du secret primaire “manuellement”) cette colonne ne nous intéresse pas."
  }
]
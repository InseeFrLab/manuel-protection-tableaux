{
  "hash": "a9ed156433be29c49c39f91c6294221f",
  "result": {
    "engine": "knitr",
    "markdown": "# Poser le secret sur plusieurs tableaux liés\n\n::: callout-tip\n## Etapes de la pause du secret sur tableaux liés\n\n1.  Analyser les tableaux pour construire une liste de tableaux et une\n    liste de variables de croisement.\n2.  Poser le secret primaire sur chacun des tableaux indépendamment.\n3.  Calculer le nombre de cellules détectées comme à risque dans chacun\n    des tableaux (i.e. le nombre cellules en secret primaire).\n4.  Poser le secret secondaire en utilisant la fonction\n    `tab_multi_manager()`.\n5.  Faire une synthèse de la pose du secret dans chaque tableau.\n:::\n\n*Objectif* : savoir protéger un ensemble de tableaux liés en utilisant\nla fonction `tab_multi_manager()` du package `rtauargus`.\n\nCe chapitre a été réalisé avec la version 1.2.0 de\n`rtauargus` et la version 4.2.3 de `TauArgus`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rtauargus)\nlibrary(dplyr)\n```\n:::\n\n\n\nAppliquons les étapes présentées ci-dessus sur quatre tableaux présents\nnativement dans le package `rtauargus`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"turnover_act_size\")\ndata(\"turnover_act_cj\")\ndata(\"turnover_nuts_size\")\ndata(\"turnover_nuts_cj\")\n```\n:::\n\n\n## Analyser les caractéristiques des tableaux\n\n### Détecter liens par les marges\n\nLes tableaux présentés ici ont la structure suivante :\n\n-   `turnover_act_size`: chiffre d'affaires ventilé par activité et\n    taille de l'entreprise\n-   `turnover_act_cj`: chiffre d'affaires ventilé par activité et taille\n    de l'entreprise\n-   `turnover_nuts_size`: chiffre d'affaires ventilé par nuts et taille\n    de l'entreprise\n-   `turnover_nuts_cj`: chiffre d'affaires ventilé par nuts et catégorie\n    juridique de l'entreprise\n\nIls sont liés par leurs marges:\n\n-   `turnover_act_size` et `turnover_act_cj` partagent les marges\n    d'activité\n-   `turnover_nuts_size` et `turnover_nuts_cj` partagent les marges des\n    nuts\n-   `turnover_act_size` et `turnover_nuts_size` partagent les marges de\n    taille\n-   `turnover_act_cj` et `turnover_nuts_cj` partagent les marges de\n    catégorie juridique\n\n### Réperer les variables hiérarchiques\n\nLes variables `ACTIVITY` et `NUTS` sont hiérarchiques. Il faut donc\nconstituer les fichiers argus nécessaires.\n\nLes tables de correspondance associées à ces variables sont présents\ndans le package : `activity_corr_table` et `nuts23_fr_corr_table`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"activity_corr_table\")\ndata(\"nuts23_fr_corr_table\")\n```\n:::\n\n\nOn utilise ces tables de correspondance pour construire les fichiers\nhiérarchiques pour TauArgus.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nact_hrc_file <- write_hrc2(activity_corr_table, \n                           file_name = \"tauargus_files/hrc/activity.hrc\")\n\nnuts_hrc_file <- write_hrc2(nuts23_fr_corr_table, \n                           file_name = \"tauargus_files/hrc/nuts23.hrc\")\n```\n:::\n\n\nCette fonction crée les fichiers hiérarchiques `.hrc` dans le répertoire\nindiqué dans l'argument `file_name` et retourne le chemin de ce\ndocument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nact_hrc_file\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tauargus_files/hrc/activity.hrc\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnuts_hrc_file\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tauargus_files/hrc/nuts23.hrc\"\n```\n\n\n:::\n:::\n\n\n### Construire une liste de tableaux et une liste de variables de croisement\n\nDans le code ci-dessous, nous manipulons les objets `list` de `R`. Si ce type d'objets ne vous est pas familier, vous pouvez vous reporter à l'annexe [-@sec-manipulerlistes] qui présente les listes et comment les manipuler. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs <- list(\n  act_size = turnover_act_size,\n  act_cj = turnover_act_cj,\n  nuts_size = turnover_nuts_size,\n  nuts_cj = turnover_nuts_cj\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_vars_4tabs <- purrr::map(\n  liste_4tabs,\n  function(data) colnames(data)[1:2]\n)\nstr(liste_vars_4tabs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ act_size : chr [1:2] \"ACTIVITY\" \"SIZE\"\n $ act_cj   : chr [1:2] \"ACTIVITY\" \"CJ\"\n $ nuts_size: chr [1:2] \"NUTS\" \"SIZE\"\n $ nuts_cj  : chr [1:2] \"NUTS\" \"CJ\"\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nAvertissement : il faut repérer les codes servant au total et de\ns'assurer qu'ils sont cohérents pour une même variable apparaissant dans\nplusieurs tableaux. En effet, deux tableaux partageant la même variable\ndoivent utiliser la même modalité pour renseigner le total. On le\nvérifie en regardant les données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(turnover_act_cj$CJ == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_size$NUTS == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_cj$NUTS == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_cj$CJ == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nIci il n'y a pas de problème puisque toutes les variables en commun ont\nune même modalité représentant les marges : \"Total\".\n\n------------------------------------------------------------------------\n\n## Poser le secret primaire sur chacun des tableaux {#sec-pose-secret-primaire}\n\nLes règles de secret appliquées ici correspondent aux règles spécifiques aux statistiques entreprises. Pour en savoir plus sur les différentes règles existantes, reportez-vous à l'annexe [-@sec-regles].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs <- liste_4tabs %>%\n  purrr::map(\n    function(df){\n      df %>%\n        mutate(\n          is_secret_freq = N_OBS > 0 & N_OBS < 3,\n          is_secret_dom = (MAX != 0) & (MAX > TOT*0.85),\n          is_secret_prim = is_secret_freq | is_secret_dom\n        )\n    }\n  )\n```\n:::\n\n\nCe code est expliqué à l'annexe [-@sec-manipulerlistes].\n\n## Calculer le nombre de cellules en secret primaire\n\nAvant de passer à l'étape suivante il est important de prendre\nconnaissance de la quantité de secret primaire présent dans les\ntableaux. En effet, s'il y a beaucoup de secret primaire alors il y aura\nsans doute beaucoup de secret secondaire et donc vraisemblablement trop\nde cellules en secret. Dans ce cas-là, il est intéressant de changer les\ntableaux en regroupant des variables ou des modalités.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs %>% purrr::walk(function(tab) count(tab, is_secret_prim) %>% print())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            337\n2 TRUE              77\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            346\n2 TRUE              60\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            388\n2 TRUE              72\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            387\n2 TRUE              65\n```\n\n\n:::\n:::\n\n\n## Poser le secret secondaire avec `tab_multi_manager()`\n\nLa fonction `tab_multi_manager()` requiert les arguments suivants :\n\n-   **list_tables** : liste de tables à protéger\n\n-   **list_explanatory_vars** : liste des noms des variables de\n    croisements présentes dans la liste des tables à protéger dans la\n    table;\n\n-   **dir_name** : le nom du répertoire qui contiendra tous les fichiers\n    créés, s'il n'existe pas, il sera créé (ex :\n    `dir_name = \"my_directory\"`).\n\n-   **hrc** : un vecteur nommé spécifiant le chemin vers le fichier\n    `.hrc` pour chaque variable hiérarchique (ex :\n    `c(ACTIVITY = “chemin_vers_fichier/act.hrc”, NUTS = “chemin_vers_fichier/nuts.hrc” )`).\n\n-   **alt_hrc** : une liste nommée utile pour traiter les hiérarchies\n    non emboîtées. Les noms de la liste sont les noms des tableaux pour\n    lesquelles une autre hiérarchie (non emboîtée en général) doit être\n    utilisée (ex : si T1 et T2 ont une variable explicative, appelée\n    `ACTIVITY`, et la même variable de réponse, mais la variable\n    `ACTIVITY` n'a pas la même hiérarchie dans les les deux tables).\n    Supposons que les hiérarchies (`act1.hrc` et `act2.hrc`) ne sont pas\n    emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit\n    :\n\n    -   `hrc = c(ACTIVITY = \"path_to_file/act_1.hrc\")` : par défaut,\n        cette hiérarchie sera utilisée pour la variable ACTIVITY.\n\n    -   `alt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\"))`\n        dans la table T2, la hiérarchie alternative sera utilisée.\n\n-   **totcode** : le code du total pour chaque variable explicative. Il\n    est recommandé d'utiliser le même code de total pour chaque\n    variable. Si par exemple le code est \"Total\" pour toutes les\n    variables. La syntaxe suivante est autorisée : `totcode = “Total”`.\n    Sinon, l'input attendu est une liste spécifiant le code total pour\n    chaque variable explicative (ex :\n    `totcode = list(ACTIVITY = “Total”, NUTS = “FR”, SIZE = “Ensemble”, CJ = “Total”)`)\n\n*Attention* : Si les totaux ne sont pas dans la table, ils seront\ncalculés par Tau-Argus, mais ils ne seront pas éligibles pour la\nsuppression primaire. Il est donc nécessaire de les fournir dans la\ntable de départ.\n\n-   **alt_totcode** : une liste nommée pour les codes de totaux\n    alternatifs (voir `alt_hrc` pour l'utilisation).\n\n-   **value** : le nom de colonne de la variable de réponse dans les\n    tableaux, il DOIT être identique pour chaque table (ex :\n    `valeur = “turnover”`). Valeur par défaut : `“value”`.\n\n-   **freq** : le nom de colonne de la variable de fréquence dans les\n    tableaux, il DOIT être le même nom pour chaque tableau (ex :\n    `freq = “frequency”`). Valeur par défaut : `“freq”`.\n\n-   **secret_var** : le nom de la variable booléenne spécifiant le\n    secret primaire dans les tables, il DOIT être le même nom pour\n    chaque table (ex : `secret_var = “is_secret_prim”`). Valeur par\n    défaut : `“is_secret_prim”`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs <- tab_multi_manager(\n    list_tables = liste_4tabs,\n    list_explanatory_vars = liste_vars_4tabs,\n    dir_name = \"tauargus_files/4tabs\",\n    hrc = list(ACTIVITY = act_hrc_file, NUTS = nuts_hrc_file),\n    totcode = \"Total\",\n    value = \"TOT\",\n    freq = \"N_OBS\",\n    secret_var = \"is_secret_prim\"\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Analyser les résultats\n\n**Analyser le journal**\n\nLa fonction `tab_multi_manager()` fournit un journal décrivant\nl'ensemble des itérations réalisées lors du processus de protection. Il\ns'agit du fichier `journal.txt` dans le répertoire mentionné dans\n`dir_name`.\n\nPour chaque étape, sont indiqués :\n\n-   Le tableau sur lequel est posé sur le secret secondaire ;\n-   Le bilan du secret posé sur ce tableau ;\n-   Le nombre de cellules communes (c'est-à-dire appartenant à plusieurs\n    tableaux) touchées.\n\nL'ensemble des cellules communes est listé en fin de processus.\n\n**Bilan du secret**\n\nL'objet retourné par la fonction `tab_multi_manager()` est une liste\ncontenant les mêmes tables que la liste placée en input auxquelles sont\najoutés les résultats des différentes étapes de la pose du secret\nsecondaire. Ainsi, la dernière variable de chaque tableau permet de\ndéterminer le statut final de chaque cellule.\n\nCe code crée une variable `statut_final` renvoyant les codes de la norme\neuropéenne :\n\n```         \n-   `A` les cellules en secret primaire à cause de la règle de\n    fréquence\n-   `B` les cellules en secret primaire à cause de la règle de\n    dominance\n-   `D` les cellules concernées par le secret secondaire\n-   `V` les cellules non touchées par le secret, c'est-à-dire les\n    cellules qui pourront être diffusées\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs <- masq_4tabs %>% \n  purrr::map(\n    function(tab){\n      tab %>% \n        rename_with(~\"is_secret_final\", last_col()) %>% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_dom ~ \"B\",\n            is_secret_final ~ \"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_4tabs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ act_size :'data.frame':\t414 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ N_OBS          : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ TOT            : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_2    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_3    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_4    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ act_cj   :'data.frame':\t406 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:406] \"01\" \"01\" \"01\" \"02\" ...\n  ..$ CJ             : chr [1:406] \"LL\" \"SP\" \"Total\" \"LL\" ...\n  ..$ N_OBS          : int [1:406] 9 9 18 240 147 387 1 1 1 3 ...\n  ..$ TOT            : num [1:406] 435 418 853 27625 15998 ...\n  ..$ MAX            : num [1:406] 263 303 303 6212 672 ...\n  ..$ is_secret_freq : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:406] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_size:'data.frame':\t460 obs. of  14 variables:\n  ..$ NUTS           : chr [1:460] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ SIZE           : chr [1:460] \"Total\" \"tr1\" \"tr2\" \"tr3\" ...\n  ..$ N_OBS          : int [1:460] 38462 37329 1096 37 19469 18919 529 21 2725 2649 ...\n  ..$ TOT            : num [1:460] 33026385 13774596 7172793 12078996 19217180 ...\n  ..$ MAX            : num [1:460] 3084242 1013320 513792 3084242 3084242 ...\n  ..$ is_secret_freq : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:460] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_cj  :'data.frame':\t452 obs. of  14 variables:\n  ..$ NUTS           : chr [1:452] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ CJ             : chr [1:452] \"LL\" \"PA\" \"SP\" \"Total\" ...\n  ..$ N_OBS          : int [1:452] 28705 1012 8745 38462 15372 983 3114 19469 1598 1 ...\n  ..$ TOT            : num [1:452] 24151930 26238 8848217 33026385 13207770 ...\n  ..$ MAX            : num [1:452] 1674878 5577 3084242 3084242 1674878 ...\n  ..$ is_secret_freq : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:452] \"V\" \"V\" \"V\" \"V\" ...\n```\n\n\n:::\n:::\n\n\nOn peut ainsi dresser notre bilan par tableau :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs %>% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %>% \n        count(statut_final) %>% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %>% \n        relocate(table)\n    }\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       table statut_final   n      part\n1   act_size            A  52 12.560386\n2   act_size            B  25  6.038647\n3   act_size            D  83 20.048309\n4   act_size            V 254 61.352657\n5     act_cj            A  35  8.620690\n6     act_cj            B  25  6.157635\n7     act_cj            D  88 21.674877\n8     act_cj            V 258 63.546798\n9  nuts_size            A  55 11.956522\n10 nuts_size            B  17  3.695652\n11 nuts_size            D  82 17.826087\n12 nuts_size            V 306 66.521739\n13   nuts_cj            A  45  9.955752\n14   nuts_cj            B  20  4.424779\n15   nuts_cj            D 101 22.345133\n16   nuts_cj            V 286 63.274336\n```\n\n\n:::\n:::\n",
    "supporting": [
      "04_secret_tableaux_lies_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "47fbde6b8fe0d6ee0761969b98fd01da",
  "result": {
    "markdown": "::: {.cell}\n\n:::\n\n\n# Utiliser les coûts {#sec-couts}\n\n::: {.callout-important}\n## Niveau expert\n:::\n  \n  *Objectif* : apprendre à utiliser l'option `cost` du package `rtauargus`\nafin de rediriger le secret secondaire.\n\nTau-Argus utilise des algorithmes d'optimisation afin de minimiser la\nperte d'information qui résulte du secret secondaire. La question qui se\npose est quelle valeur doit-être minimiser ? Plusieurs choix sont\npossibles, la valeur des cellules, le nombre de cellules, les effectifs\ndes cellules. Il est également possible de personnaliser les coûts si\nl'on souhaite prioriser la pose de secret secondaire sur certains\nagrégats.\n\n### Minimiser la valeur secrétisée\n\nTau-Argus minimise par défaut la valeur des cellules supprimées. C'est\nce qui est le plus cohérent, lorsque l'on publie un tableau c'est bien\nla valeur des cellules qui nous intéresse.\n\n### Minimiser le nombre de cellules secrétisées\n\nPour minimiser le nombre de cellules secrétisées il faut utiliser le\nparamètre `cost` et donc le définir dans notre table. si l'on souhaite\nminimiser le nombre de cellules masquées, il faut alors que le coût de\nsuppression de chaque cellule soit identique, Tau-Argus considère alors\nqu'elles ont toutes la même importance. Pour cela il faut créer une\ncolonne \"cost\" qui vaut 1 pour toutes les cellules de notre tableau.\n\n### Minimiser les effectifs secrétisés\n\nOn peut aussi considérer que la valeur importante des cellules sont\nleurs effectifs. On peut penser qu'un nombre de répondants élevé pour\nune cellule lui confère une plus grande fiabilité statistique. Pour cela\nil suffit simplement de recopier la colonne \"freq\" dans notre colonne\n\"cost\".\n\n### Orienter le secret secondaire\n\nDans certaines données on peut trouver des agrégats jugés non\nsignificatifs. Ces derniers ne seront pas publiés dans les tableaux mais\nnotés \"ns\". On peut alors s'en servir pour la pose du secret secondaire.\n\nAttention, on pourrait penser que ces cellules devraient être placées en\nsecret primaire, afin qu'elles soient considérées comme masquées quoi\nqu'il arrive. Cependant, cela peut entraîner plus de secret secondaire\nque nécessaire sachant qu'il n'est pas nécessaire de protéger ces\ncellules du risque de recoupement. L'utilisateur peut retrouver la\nvaleur de ces cellules, mais il est averti qu'elles n'ont aucune\nimportance statistique.\n\nPour prioriser le secret secondaire on crée donc pour les agrégats\nnon-significatifs la colonne \"cost\" qui vaut 1. C'est le coût minimal,\nceci indiquera à Tau-Argus que ces agrégats sont donc prioritaires pour\nle secret secondaire. Ainsi, certains coûts ne seront pas définis. Ce\nn'est pas un problème, lorsque l'on ne spécifie pas de coût pour une\ncellule, Tau-Argus va considérer que son coût de suppression est égal à\nla valeur de cette dernière.\n\n**Exemple**\n\nSi par exemple, on souhaite prioriser le secret sur la tranche d'effectif 1 `tr1`\ndans `turnover_act_size`, tableau intégré à `rtauargus`.\n\nTout d'abord, on pose le secret primaire sur le tableau.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"turnover_act_size\")\n\nturnover_act_size_detect <-  turnover_act_size %>%\n  rename(FREQ = N_OBS, VALUE = TOT) %>% \n  mutate(\n    is_secret_freq = FREQ > 0 & FREQ < 3,\n    is_secret_dom = (VALUE != 0) & (MAX > 0.85*VALUE)\n  ) %>% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n```\n:::\n\n\nPuis, on assigne on assigne la valeur 1 pour le coût de tous les croisements avec\n`tr1`.\n\n::: {.cell}\n\n```{.r .cell-code}\nturnover_act_size_ns <- turnover_act_size_detect %>%\n  mutate(cost = ifelse(SIZE == \"tr1\", 1, VALUE))\nstr(turnover_act_size_ns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [414 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE          : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ          : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE         : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX           : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n $ is_secret_freq: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n```\n:::\n:::\n\n\nOn vérifie que les coûts à 1 ont bien été appliqués.\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(turnover_act_size_ns %>% filter(cost == 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [113 × 9] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:113] \"Total\" \"AZ\" \"BE\" \"FZ\" ...\n $ SIZE          : chr [1:113] \"tr1\" \"tr1\" \"tr1\" \"tr1\" ...\n $ FREQ          : int [1:113] 217053 399 11485 26937 59426 7884 8026 11850 39819 26291 ...\n $ VALUE         : num [1:113] 1.01e+08 3.64e+04 4.69e+06 4.55e+06 1.10e+07 ...\n $ MAX           : num [1:113] 10018017 6212 990201 225864 765244 ...\n $ is_secret_freq: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:113] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ cost          : num [1:113] 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n\n\nOn pose le secret secondaire à l'aide de la fonction `tab_rtauargus()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nres_ns <- tab_rtauargus(\n  turnover_act_size_ns,\n  files_name = \"couts\",\n  dir_name = \"tauargus_files/couts\",\n  explanatory_vars = c(\"ACTIVITY\",\"SIZE\"),\n  totcode = c(\"Total\",\"Total\"),\n  freq = \"FREQ\",\n  value = \"VALUE\",\n  secret_var = \"is_secret_prim\",\n  cost_var = \"cost\",\n  verbose = FALSE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nOn peut ensuite créer une synthèse du secret posé.\n\n::: {.cell}\n\n```{.r .cell-code}\nsynthese_ns <- res_ns %>% group_by(Status) %>%\n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  ) %>% \n  group_by(statut_final) %>% \n  summarise(\n    nb_cellules = n(),\n    effectif = sum(FREQ),\n    valeur = sum(VALUE)\n  )\n\nsynthese_ns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  statut_final nb_cellules effectif      valeur\n  <chr>              <int>    <int>       <dbl>\n1 A                     52       76   22115262.\n2 B                     25    15219   37823909.\n3 D                     46   115266  142992327.\n4 V                    291  1667583 1259310983.\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
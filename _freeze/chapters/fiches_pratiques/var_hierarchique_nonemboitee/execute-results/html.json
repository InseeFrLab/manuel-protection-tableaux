{
  "hash": "9061c18859296657453233df1cd689f3",
  "result": {
    "markdown": "\n\n::: {.cell}\n\n:::\n\n\n# Poser le secret en présence de hiérarchies non-emboîtées {#sec-varhrcnonemb}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n:::::{.solutionbox-icon}\n:::::\n  Niveau moyen\n::::\n  \n  :::\n  \n  Lorsque l'on a la présence de hiérarchie non-emboîtée dans les tableaux\ntraités alors il faut construire deux tableaux et deux hiérarchies pour\nchaque hiérarchie non-emboîtée.\n\nPar exemple, le tableau `turnover_act_size` croise la NAF et les tranches d'effectifs\ndes entreprises. Si l'on décide de publier, en plus des activités\nclassiques de la NAF, un agrégat supplémentaire $AGREG = AZ + B$, \nalors il faut construire un tableau supplémentaire avec cet agrégat. En effet,\nAGREG ne peut pas s'insérer dans la hiérarchie NAF, il faut donc construire deux hiérarchies :\n  \n  -   la hiérarchie NAF (principale)\n-   la hiérarchie de l'agrégat supplémentaire (alternative)\n\nOn crée le fichier `.hrc` de la hiérarchie principale à partir de la table de correspondance incluse dans le package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(activity_corr_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t92 obs. of  3 variables:\n $ A10: chr  \"AZ\" \"AZ\" \"AZ\" \"BE\" ...\n $ A21: chr  \"A\" \"A\" \"X\" \"B\" ...\n $ A88: chr  \"01\" \"02\" \"X\" \"06\" ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_hrc2(activity_corr_table, file_name = \"hrc/NAF_principale.hrc\")\n```\n:::\n\n\nPuis on crée la hiérarchie alternative pour l'agrégat spécifique\n\n::: {.cell}\n\n```{.r .cell-code}\nalt_corr_table <- tibble::tibble(\n  niv0 = \"AGREG\",\n  niv1 = c(\"B\",\"AZ\")\n)\n\nwrite_hrc2(alt_corr_table %>% select(-niv0), file_name = \"hrc/AGREG_alt.hrc\")\n```\n:::\n\n\nOn construit les tableaux nécessaires à la pose du secret et on leur applique le secret primaire.\nA savoir le tableau sur lequel la hiérarchie principale sera appliquée.\n\n::: {.cell}\n\n```{.r .cell-code}\nturnover_act_size_detect <-  turnover_act_size %>%\n  rename(FREQ = N_OBS, VALUE = TOT) %>% \n  mutate(\n    is_secret_freq = FREQ > 0 & FREQ < 3,\n    is_secret_dom = (VALUE != 0) & (MAX > 0.85*VALUE)\n  ) %>% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n```\n:::\n\n\n\nEt le tableau sur lequel la hiérarchie alternative sera appliquée, i.e. tableau uniquement avec\nles modalités présentes dans la hiérarchie alternative et on pose le secret primaire.\n\n::: {.cell}\n\n```{.r .cell-code}\ntrunover_act_size_alt <- turnover_act_size_detect %>% \n  filter(ACTIVITY %in% c(\"AZ\",\"B\"))\n```\n:::\n\n\n\n::: {.callout-note}\n## Arguments `tab_multi_manager()` pour traiter les hiérarchies non-emboîtées\n\n-   **alt_totcode** : une liste nommée pour les codes de totaux\nalternatifs (voir `alt_hrc` pour l'utilisation).\n-   **alt_hrc** : une liste nommée utile pour traiter les hiérarchies\n    non emboîtées. Les noms de la liste sont les noms des tableaux pour\n    lesquelles une autre hiérarchie (non emboîtée en général) doit être\n    utilisée (ex : si T1 et T2 ont une variable explicative, appelée\n    `ACTIVITY`, et la même variable de réponse, mais la variable\n    `ACTIVITY` n'a pas la même hiérarchie dans les les deux tables).\nSupposons que les hiérarchies (`act1.hrc` et `act2.hrc`) ne sont pas\nemboîtées. Dans ce cas, nous écrivons les deux arguments comme suit\n:\n  \n  -   `hrc = c(ACTIVITY = \"chemin_vers_fichier/act_1.hrc\")` : par défaut,\ncette hiérarchie sera utilisée pour la variable ACTIVITY.\n-   `alt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\"))`\ndans la table T2, la hiérarchie alternative sera utilisée.\n:::\n  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_nonemb <- tab_multi_manager(\n  list_tables = list(\n    tab = turnover_act_size_detect,\n    tab_alt = trunover_act_size_alt\n  ),\n  list_explanatory_vars = list(\n    tab = c(\"ACTIVITY\",\"SIZE\"),\n    tab_alt = c(\"ACTIVITY\",\"SIZE\")\n  ),\n  dir_name = \"tauargus_files/hrc_nonemb\",\n  hrc = list(ACTIVITY = \"hrc/NAF_principale.hrc\"),\n  alt_hrc = list(\n    tab_alt = c(ACTIVITY = \"hrc/AGREG_alt.hrc\")\n  ),\n  totcode = \"Total\",\n  alt_totcode = list(\n    tab_alt = c(ACTIVITY = \"AGREG\")\n  ),\n  value = \"VALUE\",\n  freq = \"FREQ\",\n  secret_var = \"is_secret_prim\"\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_nonemb <- masq_nonemb %>% \n  purrr::map(\n    function(tab){\n      tab %>% \n        rename_with(~\"is_secret_final\", last_col()) %>% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_dom ~ \"B\",\n            is_secret_final ~ \"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_nonemb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ tab    :'data.frame':\t414 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ FREQ           : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ VALUE          : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ tab_alt:'data.frame':\t6 obs. of  11 variables:\n  ..$ ACTIVITY       : chr [1:6] \"AZ\" \"AZ\" \"AZ\" \"B\" ...\n  ..$ SIZE           : chr [1:6] \"Total\" \"tr1\" \"tr2\" \"Total\" ...\n  ..$ FREQ           : int [1:6] 405 399 6 91 75 16\n  ..$ VALUE          : num [1:6] 44475 36356 8120 1171962 1051660 ...\n  ..$ MAX            : num [1:6] 6212 6212 4812 990201 990201 ...\n  ..$ is_secret_freq : logi [1:6] FALSE FALSE FALSE FALSE FALSE FALSE\n  ..$ is_secret_dom  : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_prim : logi [1:6] FALSE FALSE FALSE FALSE TRUE FALSE\n  ..$ is_secret_1    : logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ is_secret_final: logi [1:6] FALSE FALSE FALSE FALSE TRUE TRUE\n  ..$ statut_final   : chr [1:6] \"V\" \"V\" \"V\" \"V\" ...\n```\n:::\n:::\n\n\nOn peut dresser le bilan :\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_nonemb %>% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %>% \n        count(statut_final) %>% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %>% \n        relocate(table)\n    }\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    table statut_final   n      part\n1     tab            A  52 12.560386\n2     tab            B  25  6.038647\n3     tab            D  78 18.840580\n4     tab            V 259 62.560386\n5 tab_alt            B   1 16.666667\n6 tab_alt            D   1 16.666667\n7 tab_alt            V   4 66.666667\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "52efd46641cdc041e0cf9b65f9bfe59d",
  "result": {
    "markdown": "# Manipuler les listes avec `R` {#sec-manipulerlistes}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: le package 'dplyr' a été compilé avec la version R 4.3.2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttachement du package : 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLes objets suivants sont masqués depuis 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLes objets suivants sont masqués depuis 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n\n\nLes listes sont des objets très utiles en `R` et en particulier pour produire \nefficacement les tableaux de données et les informations nécessaires lorsque nous utilisons la fonction `tab_multi_manager()` du package `rtauargus`.\n\nAlors qu'un vecteur en `R` est une collection d'objets du même type, une liste est une collection d'objets qui peuvent être très différents entre eux. On peut ainsi créer, avec la fonction `list()`, une liste contenant un vecteur d'entiers, un vecteur de charactères et un `data.frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(liste_1 <- list(1:3, c(\"spam\", \"egg\"), head(cars)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"spam\" \"egg\" \n\n[[3]]\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n```\n:::\n:::\n\n\n## Manipulations de base: créer, ajouter, supprimer\n\nPour accéder aux éléments d'une liste, il faut distinguer deux types d'indexation:\n\n- avec les crochets simples: `liste_1[1]` va permettre de récupérer la liste composée uniquement du premier objet. Cette indexation renvoie une liste. On utilisera ce type d'indexation pour extraire une sous-liste d'une liste: `liste_1[2:3]` permet, par exemple, d'extraire la sous-liste composée des éléments 2 et 3 de la liste.\n\n- avec les crochets doubles: `liste_1[[1]]` permet d'accéder au premier élément de la liste. Le type de l'objet renvoyé est le type de l'objet placé dans la liste à l'index renseigné (dans notre cas un vecteur d'entiers). On utilisera cette indexation pour extraire un objet particulier de la liste.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_1[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(liste_1[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nliste_1[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(liste_1[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nPour ajouter un élément à une liste, plusieurs techniques sont possibles:\n\n- ajouter une liste à une autre liste avec la fonction `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(liste_2 <- list(LETTERS, head(mtcars)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[2]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\n(liste_3 <- c(liste_1, liste_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"spam\" \"egg\" \n\n[[3]]\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n\n[[4]]\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n[[5]]\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\nlength(liste_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n- ajouter un élément avec l'indexation simple:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_3[6] <- pi\nlength(liste_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nSi on ajoute un élément à un index supérieur à la longueur de la liste + 1, `R` va créer automatiquement des éléments vides (de type `NULL`) sur les index \"oubliés\". Ici, notre `liste_3` contient 6 objets, si j'ajoute un élément à l'index `9`, la liste aura une longueur de `9` avec deux objets `NULL` en positions `7` et `8`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_3[9] <- pi^2\nlength(liste_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nliste_3[7:8]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n```\n:::\n:::\n\n\n\n## Nommer les éléments d'une liste\n\nIl est souvent pratique de donner des noms à chaque élément de la liste. Cela permet de récupérer les objets sans avoir à connaître leur position dans la liste. La fonction `names()` permet d'accoler un nom à chaque élément de la liste. On fera bien attention à fournir un vecteur de noms qui soit de la même longueur que la liste.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(liste_1) <- c(\"vec_int\", \"vec_char\", \"cars_df\")\nnames(liste_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"vec_int\"  \"vec_char\" \"cars_df\" \n```\n:::\n\n```{.r .cell-code}\nliste_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n\n$cars_df\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n4     7   22\n5     8   16\n6     9   10\n```\n:::\n:::\n\n\n\nPour récupérer un élément de la liste grçace à son nom, on pourra utiliser les deux types d'indexation vues ci-dessus en utilisant non pas les index de position dans la liste mais les noms des objets.\n\nPour récupérer une sous-liste, on fera:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_1[\"vec_char\"] # retourne une sous-liste d'un élément\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vec_char\n[1] \"spam\" \"egg\" \n```\n:::\n\n```{.r .cell-code}\nliste_1[c(\"vec_int\", \"vec_char\")] # retourne une sous-liste de deux éléments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n```\n:::\n:::\n\n\n\nPour retourner un objet de la liste, on fera: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_1[[\"vec_char\"]] # retourne l'élément vec_char en tant que vecteur\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"spam\" \"egg\" \n```\n:::\n:::\n\n\nL'accès à un objet d'une liste est aussi possible en utilisant le `$`. Ainsi, l'écriture suivante est identique à la précédente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_1$vec_char\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"spam\" \"egg\" \n```\n:::\n:::\n\n\nOn pourra nommer les éléments d'une liste au moment de la créer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_df <- list(\n  df1 = cars,\n  df2 = mtcars,\n  df3 = iris,\n  df4 = CO2\n)\nnames(liste_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"df1\" \"df2\" \"df3\" \"df4\"\n```\n:::\n:::\n\n\n\n## Supprimer un élément d'une liste\n\nOn utilisera le code suivant pour supprimer le troisième élément d'une liste:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_1[-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vec_int\n[1] 1 2 3\n\n$vec_char\n[1] \"spam\" \"egg\" \n```\n:::\n:::\n\n\nEt le code suivant pour supprimer les éléments 7 et 8 de `liste_3`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(liste_3[c(-7,-8)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n\n## Appliquer une fonction à chaque élément une liste avec la fonction `lapply()`\n\nPour cette section, nous utiliserons principalement des listes dont tous les éléments sont du même type, en particulier des `data.frames`.\n\nPour appliquer une même fonction à tous les éléments d'une liste, il n'est pas besoin d'écrire une boucle `for` car la fonction `lapply()` s'en charge pour nous.\n\nUn premier exemple: Nous souhaitons connaître les dimensions de chaque `data.frame` qui compose la liste `liste_df`. Le premier argument de `lapply` est la liste sur laquelle nous travaillons et le second argument est la fonction que nous voulons appliquer sur chaque élément. Il s'agit, ici, de la fonction `dim()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(liste_df, dim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n[1] 50  2\n\n$df2\n[1] 32 11\n\n$df3\n[1] 150   5\n\n$df4\n[1] 84  5\n```\n:::\n:::\n\n\nLa fonction `lapply()` retourne une liste de même longueur que la liste de départ et chaque élément de la liste contient le résultat de la fonction `dim()` soit un vecteur de deux éléments (nombre de lignes et nombre de colonnes d'un `data.frame`).\n\nSecond exemple: Nous souhaitons afficher les deux premières lignes de chaque `data.frame`. Ici, nous allons utiliser la fonction `head()` qui affiche, par défaut les 6 premières lignes. Il nous faut donc changer un paramètre de la fonction. Nous pouvons:\n\n- soit créer une fonction anonyme (lambda):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(liste_df, function(df) head(df, n = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n```\n:::\n\n```{.r .cell-code}\nlapply(liste_df, \\(df) head(df, n = 2)) # écriture de fonction apparue avec R 4.2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n```\n:::\n:::\n\n\nDans cette écriture `df` prendra successivement comme valeur les objets de la liste, comme le `i` dans une boucle `for(i in ...)`.\n\n- soit contracter l'écriture (c'est possible ici car nous ne modifions pas l'objet `df`) de la manière suivante:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(liste_df, head, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n  speed dist\n1     4    2\n2     4   10\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n\n$df4\n  Plant   Type  Treatment conc uptake\n1   Qn1 Quebec nonchilled   95   16.0\n2   Qn1 Quebec nonchilled  175   30.4\n```\n:::\n:::\n\n\n\nTroisième exemple: Nous souhaitons, dans chacun des tableaux, ajouter une variable servant d'identifiant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_df2 <- lapply(\n  liste_df, \n  function(df){\n    df$index <- 1:nrow(df)\n    return(df)\n  }\n)\nlapply(liste_df2, head, n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n  speed dist index\n1     4    2     1\n2     4   10     2\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb index\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4     1\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4     2\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species index\n1          5.1         3.5          1.4         0.2  setosa     1\n2          4.9         3.0          1.4         0.2  setosa     2\n\n$df4\n  Plant   Type  Treatment conc uptake index\n1   Qn1 Quebec nonchilled   95   16.0     1\n2   Qn1 Quebec nonchilled  175   30.4     2\n```\n:::\n:::\n\n\n\n## Appliquer une fonction à chaque élément une liste avec la fonction `purrr::map()`\n\nLa package `purrr` met à disposition des fonctions qui permettent de manipuler les listes. Une aide précieuse pour découvrir tous les trésors du package est fournie ici: [](https://raw.githubusercontent.com/rstudio/cheatsheets/master/purrr.pdf)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: le package 'purrr' a été compilé avec la version R 4.3.2\n```\n:::\n:::\n\n\n\n- La fonction `map()` est un équivalent de la fonction `lapply()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(liste_df, dim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n[1] 50  2\n\n$df2\n[1] 32 11\n\n$df3\n[1] 150   5\n\n$df4\n[1] 84  5\n```\n:::\n:::\n\n\nL'avantage du package est de fournir des variantes très utiles de la fonction `map()`, en particulier la fonction `imap()` qui permet d'accéder non pas seulement à tous les éléments de la liste mais aussi à leur index ou à leur nom. \n\nPar exemple, imaginons que nous souhaitons ajouter à chaque `data.frame` de la liste `liste_df` une variable contenant le nom du tableau. Avec la fonction `imap()` cela s'écrit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_df <- imap(liste_df, \\(df, nom) df %>% mutate(tableau = nom))\nmap(liste_df, head, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$df1\n  speed dist tableau\n1     4    2     df1\n2     4   10     df1\n\n$df2\n              mpg cyl disp  hp drat    wt  qsec vs am gear carb tableau\nMazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4     df2\nMazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4     df2\n\n$df3\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species tableau\n1          5.1         3.5          1.4         0.2  setosa     df3\n2          4.9         3.0          1.4         0.2  setosa     df3\n\n$df4\n  Plant   Type  Treatment conc uptake tableau\n1   Qn1 Quebec nonchilled   95   16.0     df4\n2   Qn1 Quebec nonchilled  175   30.4     df4\n```\n:::\n:::\n\n\nAvec `imap()`, la fonction anonyme n'a plus un mais deux arguments: l'un (que nous appelons `df` ici) représente chaque objet de la liste et l'autre (nommé `nom` ici) représente le nom de chaque élément. Ainsi, pour le premier élément, `df` prendra la valeur `liste_df[[1]]` et `nom` prendra la valeur `df1`.\n\n\n## Poser le secret primaire sur une liste de `data.frames`\n\nL'utilisation des listes est nécessaire pour utiliser la fonction `tab_muli_manager` de `rtauargus`. Mais, elle est aussi intéressante en amont, par exemple dans la pose du secret primaire comme dans l'exemple fourni à la section [-@sec-pose-secret-primaire].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs <- liste_4tabs %>%\n  map(\n    function(df){\n      df %>%\n        mutate(\n          is_secret_freq = N_OBS > 0 & N_OBS < 3,\n          is_secret_dom = (MAX != 0) & (MAX > TOT*0.85),\n          is_secret_prim = is_secret_freq | is_secret_dom\n        )\n    }\n  )\n```\n:::\n\n\nLe code ci-dessus permet d'appliquer à chacun des 4 `data.frames` qui composent la liste `liste_4tabs` une fonction anonyme qui:\n\n- construit la variable `is_secret_freq`, permettant d'indiquer si une cellule respecte ou non la règle de fréquence (avec les règles des statistiques entreprises);\n- construit la variable `is_secret_dom`, permettant d'indiquer si une cellule respecte ou non la règle de dominance;\n- construit la variable `is_secret_prim`, permettant d'indiquer si une cellule respecte ou non les deux règles à la fois.\n\nEn sortie, nous obtiendrons ainsi une liste composés des mêmes 4 `data.frames` qui auront chacun les trois variables de secret primaire construites ici en plus.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
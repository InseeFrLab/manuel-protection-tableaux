{
  "hash": "bf7c0b2f98bd137dcf20ffb53a1d344e",
  "result": {
    "markdown": "---\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n# Fiches pratiques\n\nCes fiches pratiques ont été réalisées avec la version 1.2.0 de `rtauargus` et la version 4.2.3 de `TauArgus`.\n\n## Structure des données\n\nTous les tableaux fournis en entrée de `rtauargus` ont une structure identique :\n\n-   Les variables décrivant les croisements (variables catégorielles) sont placées au début\n-   `FREQ` la variable indiquant le nombre d'unités statistiques contribuant à la cellule;\n-   `VALUE` la variable indiquant la somme pondérée des valeurs de\n    l'ensemble des contributeurs à la cellule (ex : un chiffre\n    d'affaires, un nombre de personnes en emploi au 31/12, etc.);\n-   `MAX` la valeur du plus gros contributeur à la cellule.\n\nN.B : pour les tableaux de fréquence `FREQ` = `VALUE`.\n\n## Construire des tableaux agrégés à partir de microdonnées\n\n## Poser le secret sur un tableau\n\n::: {.callout-tip}\n## Etapes de la pose du secret sur un seul tableau\n\n1.    Poser le secret primaire\n2.    Calculer le nombre de cellules détectées comme à risque\n3.    Poser le secret secondaire à l'aide de la fonction `tab_rtauargus()`\n4.    Faire une synthèse du secret posé\n:::\n\nPoser un masque de secret sur un tableau comprend les étapes suivantes :\n\n1.  Poser le secret primaire en créant des variables indicatrices :\n\n-   Pour chacun des tableaux on ajoute une variable booléenne indiquant\n    si la cellule est problématique (`TRUE`) ou non (`FALSE`), au\n    regarde des règles pertinentes à appliquer comme : la règle de\n    fréquence `is_secret_freq` ou la règle de dominance `is_secret_dom`\n-   Ensuite, on crée une variable résumant le secret primaire\n    `is_secret_prim` :\n    -   `is_secret_prim = is_secret_freq` si seule la règle de fréquence\n        doit s'appliquer\n    -   `is_secret_prim = is_secret_freq | is_secret_dom` si les deux\n        règles doivent s'appliquer\n\nVoici un exemple de code pour les règles classiques en statistiques\nd'entreprises :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rtauargus)\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLe tableau `T0` présente le chiffre d'affaires des entreprises ventilé par\nleur activité et leur taille.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(T0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [414 × 5] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY: chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE    : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ    : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE   : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX     : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n```\n:::\n\n```{.r .cell-code}\n# Pose du secret \"manuelle\"\nT0_detect <- T0 %>% \n  mutate(\n      is_secret_freq = FREQ > 0 & FREQ < 3,\n      is_secret_dom = (VALUE != 0) & (MAX > 0.85*VALUE)\n    ) %>% \n  mutate(\n    is_secret_prim = is_secret_freq | is_secret_dom\n  )\n\n# Résultat\nstr(T0_detect)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [414 × 8] (S3: tbl_df/tbl/data.frame)\n $ ACTIVITY      : chr [1:414] \"AZ\" \"BE\" \"FZ\" \"GI\" ...\n $ SIZE          : chr [1:414] \"Total\" \"Total\" \"Total\" \"Total\" ...\n $ FREQ          : int [1:414] 405 12878 28043 62053 8135 8140 11961 41359 26686 25108 ...\n $ VALUE         : num [1:414] 44475 24827613 8907311 26962063 8584917 ...\n $ MAX           : num [1:414] 6212 1442029 1065833 3084242 3957364 ...\n $ is_secret_freq: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_dom : logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ is_secret_prim: logi [1:414] FALSE FALSE FALSE FALSE FALSE FALSE ...\n```\n:::\n:::\n\n\n2.  Calculer le nombre de cellules détectées comme à risque\n\n3.  Poser le secret secondaire en utilisant le package `rtauargus` en\n    utilisant la fonction `tab_rtauargus()`.\n\nLa fonction `tab_rtauargus()` requiert les arguments suivants :\n\n-   `tabular`: la table à protéger\n-   `dir_name`: le nom du répertoire où les fichiers seront sauvegardés\n-   `files_name`: le nom utilisé pour nommer les fichiers (chaque\n    fichier a une extension différente);\n-   `explanatory_vars`: le nom des variables de croisements présents\n    dans la table;\n-   `secret_var`: le nom de la variable indiquant si une cellule est à\n    risque ou non (secret primaire);\n-   `value` = nom de la variable de réponse;\n-   `freq` = nom de la variable d'effectifs;\n-   `totcode`: le code utilisé pour indiquer le total pour chacune des\n    variables de croisements (`explanatory_vars`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Localisation de tauargus sur AUS\nloc_tauargus <- \"Y:/Logiciels/TauArgus/TauArgus4.2.3/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n\n# Préciser la localisation de tauargus\nloc_tauargus <- \"C:/Users/tmm7an/Documents/SDC/TauArgus/TauArgus4.2.3/TauArgus.exe\"\noptions(rtauargus.tauargus_exe = loc_tauargus)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq <- tab_rtauargus(\n  T0_detect,\n  dir_name = \"tauargus_files/ex_T0\",\n  files_name = \"T0\",\n  explanatory_vars = c(\"ACTIVITY\",\"SIZE\"),\n  secret_var = \"is_secret_prim\",\n  value = \"VALUE\",\n  freq = \"FREQ\",\n  totcode = c(ACTIVITY=\"Total\",SIZE=\"Total\"),\n  verbose = FALSE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n4.  Calculer le nombre de cellules selon leur statut final en suivant la\n    norme européenne :\n\n-   `A` les cellules en secret primaire à cause de la règle de fréquence\n-   `B` les cellules en secret primaire à cause de la règle de dominance\n    (dans le futur ces cellules pourraient être notées `O`)\n-   `D` les cellules concernées par le secret secondaire\n-   `V` les cellules non touchées par le secret, c'est-à-dire les\n    cellules qui pourront être diffusées.\n\nPour faire le bilan du secret, le mieux est de modifier la variable\n`Status` fournie par Tau-Argus. En effet, cette variable ne permet pas\nde faire la distinction entre les deux types de secret primaire (fréquence ou\ndominance), on modifie donc ces modalités pour faire apparaître cette distinction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq <- T0_masq %>% \n  mutate(\n    statut_final = case_when(\n      is_secret_freq ~ \"A\",\n      is_secret_dom ~ \"B\",\n      TRUE ~ Status,\n    )\n  )\n```\n:::\n\n\nAfin de bien appréhender l'impact du secret posé, on va non seulement\ncompter le nombre de cellules masquées, mais aussi calculer la valeur\ndes cellules masquées.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT0_masq %>% \n  group_by(statut_final) %>% \n  summarise(\n    n_cell = n(),\n    val_cell = sum(VALUE)\n  ) %>%\n  mutate(\n    pc_n_cell = n_cell/sum(n_cell)*100,\n    pc_val_cell = val_cell/sum(val_cell)*100\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  statut_final n_cell    val_cell pc_n_cell pc_val_cell\n  <chr>         <int>       <dbl>     <dbl>       <dbl>\n1 A                52   22115262.     12.6         1.51\n2 B                25   37823909.      6.04        2.59\n3 D                46   21032941.     11.1         1.44\n4 V               291 1381270369.     70.3        94.5 \n```\n:::\n:::\n\n\nUn bon indicateur de la qualité du secret secondaire posé consiste à\nrapporter le nombre de cellules supprimées lors de cette phase au nombre\nde cellules détectées comme à risque (secret primaire). Ici par exemple,\nnous avons un ratio de $46/(52+25) = 0.6$. Ainsi, pour protéger une case\nen secret primaire, Tau-argus a dû masquer 0.6 cellule(s) ; ce qui est\ntrès peu.\n\nEn effet, pour un tableau à deux dimensions, la présence d'un\nsecret primaire engendre la suppression d'au moins 3 cellules\nsupplémentaires. Donc, le ratio obtenu sur cet exemple indique qu'un certain \nnombre de cellules en secret primaire se protègent entre elles.\n\n## Prendre en compte une variable hiérarchique\n\nReprenons ici l'exemple de la variable `geo` qui est une variable\nhiérarchique puisqu'il existe des emboîtements entre les différents\nniveaux.\n\n\n```{mermaid}\nflowchart TD\n  A[Pays] --> B[Nord]\n  A --> C[Ouest]\n  A --> D[Est]\n  A --> E[Sud]\n  B --> F[N1]\n  B --> G[N2]\n  B --> H[N3]\n  C --> I[O1]\n  C --> J[O2]\n  C --> K[O3]\n  C --> L[O4]\n  D --> M[E1]\n  D --> N[E2]\n  D --> O[E3]\n  E --> P[S1]\n  E --> Q[S2]\n```\n\n\nPour prendre en compte cette hiérarchie il faut d'abord pouvoir la\nreprésenter de telle sorte que Tau-Argus comprenne les différents\nemboîtements présents.\n\n### Première option\n\nLa première option consiste à créer le fichier nécessaire (extension\n`.hrc`) à la main. Ceci est tout à fait pertinent si la hiérarchie n'est\npas trop étendue.\n\nTau-Argus attend en effet un type de fichier bien particulier, dont\nl'extension est `.hrc`. Il s'agit d'un simple fichier texte où les\ndifférents emboîtements sont écrits les uns en-dessous des autres. Un\nsymbole (le `@`) est utilisé pour préciser le niveau de chacun des\nemboîtements au sein de la hiérarchie.\n\nDans notre exemple on écrirait le fichier de la façon suivante :\n\n\n::: {.cell}\n\n```{.tex .cell-code}\nNord\n@N1\n@N2\n@N3 \nOuest \n@O1 \n@O2 \n@O3 \n@O4 \nEst\n@E1 \n@E2 \n@E3 \nSud \n@S1 \n@S2\n```\n:::\n\n\nOn remarque que le total `Pays` n'est pas inclus dans le fichier `.hrc`\nc'est parce qu'il ne faut **pas indiquer le super-total de la\nhiérarchie** à Tau-Argus.\n\n### Seconde option\n\nQuand la hiérarchie est très étendue, l'écriture manuelle du fichier de\nhiérarchie est pénible. Or, quand ce genre de cas se présente, il existe\nsouvent une table de correspondance permettant d'associer les différents\nniveaux entre eux.\n\nNous appelons table de correspondance une table qui précise l'ensemble\ndes niveaux associés aux emboîtements les plus fins.\n\nLa table de correspondance représentant la hiérarchie ci-dessus est la suivante:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npays_corr_table <- tibble(\n  niv0 = \"Pays\",\n  niv1 = c(rep(\"Nord\",3),rep(\"Ouest\",4),rep(\"Est\",3), rep(\"Sud\",2)),\n  niv2 = c(paste0(\"N\",1:3),paste0(\"O\",1:4),paste0(\"E\",1:3), paste0(\"S\",1:2))\n)\npays_corr_table\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 3\n   niv0  niv1  niv2 \n   <chr> <chr> <chr>\n 1 Pays  Nord  N1   \n 2 Pays  Nord  N2   \n 3 Pays  Nord  N3   \n 4 Pays  Ouest O1   \n 5 Pays  Ouest O2   \n 6 Pays  Ouest O3   \n 7 Pays  Ouest O4   \n 8 Pays  Est   E1   \n 9 Pays  Est   E2   \n10 Pays  Est   E3   \n11 Pays  Sud   S1   \n12 Pays  Sud   S2   \n```\n:::\n:::\n\n\nAvec la fonction `write_hrc2()` du package `rtauargus`, on peut transformer\nla table de correspondance en un fichier `hrc`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_hrc2(pays_corr_table %>% select(-niv0), file_name = \"hrc/pays_TA_2.hrc\")\n```\n:::\n\n\nRemarque: La fonction `rtauargus::write_hrc2()` n'accepte pas\nde valeurs manquantes dans la table en entrée. Lorsqu'une hiérarchie n'a pas la même nombre de sous-niveaux selon les branches on répète la modalité du niveau supérieur sur les niveaux inférieurs pour ne pas avoir de cases vides.\n\nExemple : pour la hiérarchie ci-dessous on répète la modalité `C` dans la table de correspondance.\n\n\n```{mermaid}\nflowchart TD\n  A[Total] --> B[A]\n  A --> C[B]\n  A --> D[C]\n  B --> E[A1]\n  B --> F[A2]\n  C --> G[B1]\n  C --> H[B2]\n  H --> I[B21]\n  H --> J[B22]\n```\n\n::: {.cell}\n\n```{.r .cell-code}\ncorr_tab <- tibble(\n  niv0 = \"ALL\",\n  niv1 = c(rep(\"A\",2),rep(\"B\",3), \"C\"),\n  niv2 = c(\"A1\",\"A2\",\"B1\",rep(\"B2\",2), \"C\"),\n  niv3 = c(\"A1\",\"A2\",\"B1\", \"B21\", \"B22\", \"C\")\n)\ncorr_tab\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  niv0  niv1  niv2  niv3 \n  <chr> <chr> <chr> <chr>\n1 ALL   A     A1    A1   \n2 ALL   A     A2    A2   \n3 ALL   B     B1    B1   \n4 ALL   B     B2    B21  \n5 ALL   B     B2    B22  \n6 ALL   C     C     C    \n```\n:::\n:::\n\n\n## Poser le secret sur plusieurs tableaux liés (par les marges)\n\n*Objectif* : savoir protéger un ensemble de tableaux liés en utilisant\nla fonction `tab_multi_manager()` du package `rtauargus`.\n\n::: {.callout-tip}\n## Etapes de la pause du secret sur tableaux liés\n\n1.  Analyser les tableaux pour construire une liste de tableaux et une liste de variables de croisement.\n\n2.  Poser le secret primaire sur chacun des tableaux indépendamment.\n\n3.  Calculer le nombre de cellules détectées comme à risque dans chacun\n    des tableaux (i.e. le nombre cellules en secret primaire).\n\n4.  Poser le secret secondaire en utilisant la fonction\n    `tab_multi_manager()`.\n\n5.  Faire une synthèse de la pose du secret dans chaque tableau..\n:::\n\n\n\nAppliquons les étapes présentées ci-dessus sur quatre tableaux présents nativement dans le package `rtauargus`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"turnover_act_size\")\ndata(\"turnover_act_cj\")\ndata(\"turnover_nuts_size\")\ndata(\"turnover_nuts_cj\")\n```\n:::\n\n\n### Analyser les caractéristiques des tableaux\n\n#### Détecter liens par les marges\nLes tableaux présentés ici ont la structure suivante :\n\n- `turnover_act_size`: chiffre d'affaires ventilé par activité et taille de l'entreprise\n- `turnover_act_cj`: chiffre d'affaires ventilé par activité et taille de l'entreprise\n- `turnover_nuts_size`: chiffre d'affaires ventilé par nuts et taille de l'entreprise\n- `turnover_nuts_cj`: chiffre d'affaires ventilé par nuts et catégorie juridique de l'entreprise\n\nIls sont liés par leurs marges:\n\n- `turnover_act_size` et `turnover_act_cj` partagent les marges d'activité\n- `turnover_nuts_size` et `turnover_nuts_cj` partagent les marges des nuts\n- `turnover_act_size` et `turnover_nuts_size` partagent les marges de taille\n- `turnover_act_cj` et `turnover_nuts_cj` partagent les marges de catégorie juridique\n\n\n#### Réperer les variables hiérarchiques\nLes variables `ACTIVITY` et `NUTS` sont hiérarchiques. Il faut donc constituer les fichiers argus nécessaires.\n\nLes tables de correspondance associées à ces variables sont présents dans le package : `activity_corr_table` et `nuts23_fr_corr_table`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"activity_corr_table\")\ndata(\"nuts23_fr_corr_table\")\n```\n:::\n\n        \nOn utilise ces tables de correspondance pour construire les fichiers hiérarchiques pour TauArgus.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nact_hrc_file <- write_hrc2(activity_corr_table, \n                           file_name = \"tauargus_files/hrc/activity.hrc\")\n\nnuts_hrc_file <- write_hrc2(nuts23_fr_corr_table, \n                           file_name = \"tauargus_files/hrc/nuts23.hrc\")\n```\n:::\n\n\nCette fonction crée les fichiers hiérarchiques `.hrc` dans le répertoire indiqué dans l'argument `file_name` et retourne le chemin de ce document.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nact_hrc_file\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tauargus_files/hrc/activity.hrc\"\n```\n:::\n\n```{.r .cell-code}\nnuts_hrc_file\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tauargus_files/hrc/nuts23.hrc\"\n```\n:::\n:::\n\n\n#### Construire une liste de tableaux et une liste de variables de croisement\n\nFaire référence à la partie sur les listes (écrite plus tard par Julien).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs <- list(\n  act_size = turnover_act_size,\n  act_cj = turnover_act_cj,\n  nuts_size = turnover_nuts_size,\n  nuts_cj = turnover_nuts_cj\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_vars_4tabs <- purrr::map(\n  liste_4tabs,\n  function(data) colnames(data)[1:2]\n)\nstr(liste_vars_4tabs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ act_size : chr [1:2] \"ACTIVITY\" \"SIZE\"\n $ act_cj   : chr [1:2] \"ACTIVITY\" \"CJ\"\n $ nuts_size: chr [1:2] \"NUTS\" \"SIZE\"\n $ nuts_cj  : chr [1:2] \"NUTS\" \"CJ\"\n```\n:::\n:::\n\n\n\n---\n\nAvertissement : il faut  repérer les codes servant au total et de s'assurer qu'ils sont\ncohérents pour une même variable apparaissant dans plusieurs tableaux. En effet, \ndeux tableaux partageant la même variable doivent utiliser la même \nmodalité pour renseigner le total. On le vérifie en regardant les données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(turnover_act_cj$CJ == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_size$NUTS == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_cj$NUTS == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(turnover_nuts_cj$CJ == \"Total\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIci il n'y a pas de problème puisque toutes les variables en commun ont une même modalité représentant les marges : \"Total\".\n\n---\n\n### Poser le secret primaire sur chacun des tableaux\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs <- liste_4tabs %>%\n  purrr::map(\n    function(df){\n      df %>%\n        mutate(\n          is_secret_freq = N_OBS > 0 & N_OBS < 3,\n          is_secret_dom = (MAX != 0) & (MAX > TOT*0.85),\n          is_secret_prim = is_secret_freq | is_secret_dom\n        )\n    }\n  )\n```\n:::\n\n\n\n### Calculer le nombre de cellules en secret primaire\nAvant de passer à l'étape suivante il est important de prendre connaissance de \nla quantité de secret primaire présent dans les tableaux. En effet, s'il y a beaucoup de secret primaire alors il y aura sans doute beaucoup de secret secondaire et donc vraisemblablement trop de cellules en secret. Dans ce cas-là, il est intéressant de changer les tableaux en regroupant des variables ou des modalités.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nliste_4tabs %>% purrr::walk(function(tab) count(tab, is_secret_prim) %>% print())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            337\n2 TRUE              77\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            346\n2 TRUE              60\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            388\n2 TRUE              72\n# A tibble: 2 × 2\n  is_secret_prim     n\n  <lgl>          <int>\n1 FALSE            387\n2 TRUE              65\n```\n:::\n:::\n\n\n### Poser le secret secondaire avec `tab_multi_manager()`\n\nLa fonction `tab_multi_manager()` requiert les arguments suivants :\n\n-   **list_tables** : liste de tables à protéger\n\n-   **list_explanatory_vars** : liste des noms des variables de\n    croisements présentes dans la liste des tables à protéger dans la\n    table;\n\n-   **dir_name** : le nom du répertoire qui contiendra tous les fichiers\n    créés, s'il n'existe pas, il sera créé (ex :\n    `dir_name = \"my_directory\"`).\n\n-   **hrc** : un vecteur nommé spécifiant le chemin vers le fichier\n    `.hrc` pour chaque variable hiérarchique (ex :\n    `c(ACTIVITY = “chemin_vers_fichier/act.hrc”, NUTS = “chemin_vers_fichier/nuts.hrc” )`).\n\n-   **alt_hrc** : une liste nommée utile pour traiter les hiérarchies\n    non emboîtées. Les noms de la liste sont les noms des tableaux pour\n    lesquelles une autre hiérarchie (non emboîtée en général) doit être\n    utilisée (ex : si T1 et T2 ont une variable explicative, appelée\n    `ACTIVITY`, et la même variable de réponse, mais la variable\n    `ACTIVITY` n'a pas la même hiérarchie dans les les deux tables).\n    Supposons que les hiérarchies (`act1.hrc` et `act2.hrc`) ne sont pas\n    emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit\n    :\n\n    -   `hrc = c(ACTIVITY = \"path_to_file/act_1.hrc\")` : par défaut,\n        cette hiérarchie sera utilisée pour la variable ACTIVITY.\n\n    -   `alt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\"))`\n        dans la table T2, la hiérarchie alternative sera utilisée.\n\n-   **totcode** : le code du total pour chaque variable explicative. Il\n    est recommandé d'utiliser le même code de total pour chaque\n    variable. Si par exemple le code est \"Total\" pour toutes les\n    variables. La syntaxe suivante est autorisée : `totcode = “Total”`.\n    Sinon, l'input attendu est une liste spécifiant le code total pour\n    chaque variable explicative (ex :\n    `totcode = list(ACTIVITY = “Total”, NUTS = “FR”, SIZE = “Ensemble”, CJ = “Total”)`)\n\n*Attention* : Si les totaux ne sont pas dans la table, ils seront\ncalculés par Tau-Argus, mais ils ne seront pas éligibles pour la\nsuppression primaire. Il est donc nécessaire de les fournir dans la\ntable de départ.\n\n-   **alt_totcode** : une liste nommée pour les codes de totaux\n    alternatifs (voir `alt_hrc` pour l'utilisation).\n\n-   **value** : le nom de colonne de la variable de réponse dans les\n    tableaux, il DOIT être identique pour chaque table (ex :\n    `valeur = “turnover”`). Valeur par défaut : `“value”`.\n\n-   **freq** : le nom de colonne de la variable de fréquence dans les\n    tableaux, il DOIT être le même nom pour chaque tableau (ex :\n    `freq = “frequency”`). Valeur par défaut : `“freq”`.\n\n-   **secret_var** : le nom de la variable booléenne spécifiant le\n    secret primaire dans les tables, il DOIT être le même nom pour\n    chaque table (ex : `secret_var = “is_secret_prim”`). Valeur par\n    défaut : `“is_secret_prim”`.\n\n-   **cost_var** : variable numeric qui permet de changer le coût de\n    suppression d'une cellule, pris en compte dans les algorithmes de\n    secret secondaire. Par défaut le coût correspond à la valeur de la\n    cellule. Peut être spécifié pour chacune des cellules. Peut contenir\n    des NA pour les coûts que l'on ne souhaite pas modifier.\n\n-   **suppress** : algorithme de gestion du secret secondaire (syntaxe\n    batch de Tau-Argus), ainsi que les potentiels paramètres associés.\n    Valeur par défaut : `MOD(1,5,1,0,0)`\n\n-   **ip_start** : les intervalles de protection pour la première\n    itération sur une table donnée (nombre entier). La valeur par défaut\n    est 10.\n\n-   **ip_end** : les intervalles de protection pour la deuxième\n    itération sur une table (nombre entier). Valeur par défaut : 0.\n\n-   **num_iter_max** : nombre d'itérations maximum sur un tableau, ce\n    paramètre est ici pour assurer le fait que la fonction va s'arrêter.\n    En pratique on n'atteint jamais la limite de 10. La valeur par\n    défaut est 10.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs <- tab_multi_manager(\n    list_tables = liste_4tabs,\n    list_explanatory_vars = liste_vars_4tabs,\n    dir_name = \"tauargus_files/4tabs\",\n    hrc = list(ACTIVITY = act_hrc_file, NUTS = nuts_hrc_file),\n    totcode = \"Total\",\n    value = \"TOT\",\n    freq = \"N_OBS\",\n    secret_var = \"is_secret_prim\"\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### Analyser les résultats\n\n**Analyser le journal**\n\nLa fonction `tab_multi_manager()` fournit un journal décrivant\nl'ensemble des itérations réalisées lors du processus de protection. Il\ns'agit du fichier `journal.txt` dans le répertoire mentionné dans\n`dir_name`.\n\nPour chaque étape, sont indiqués :\n\n-   Le tableau sur lequel est posé sur le secret secondaire ;\n-   Le bilan du secret posé sur ce tableau ;\n-   Le nombre de cellules communes (c'est-à-dire appartenant à plusieurs\n    tableaux) touchées.\n\nL'ensemble des cellules communes est listé en fin de processus.\n\n**Bilan du secret**\n\nL'objet retourné par la fonction `tab_multi_manager()` est une liste\ncontenant les mêmes tables que la liste placée en input auxquelles sont\najoutés les résultats des différentes étapes de la pose du secret\nsecondaire. Ainsi, la dernière variable de chaque tableau permet de\ndéterminer le statut final de chaque cellule.\n\nCe code crée une variable `statut_final` renvoyant les codes de la norme\neuropéenne :\n\n    -   `A` les cellules en secret primaire à cause de la règle de\n        fréquence\n    -   `B` les cellules en secret primaire à cause de la règle de\n        dominance\n    -   `D` les cellules concernées par le secret secondaire\n    -   `V` les cellules non touchées par le secret, c'est-à-dire les\n        cellules qui pourront être diffusées\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs <- masq_4tabs %>% \n  purrr::map(\n    function(tab){\n      tab %>% \n        rename_with(~\"is_secret_final\", last_col()) %>% \n        mutate(\n          statut_final = case_when(\n            is_secret_freq ~ \"A\",\n            is_secret_final ~\"D\",\n            TRUE ~ \"V\"\n          )\n        )\n    }\n  )\nstr(masq_4tabs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ act_size :'data.frame':\t414 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:414] \"01\" \"01\" \"02\" \"02\" ...\n  ..$ SIZE           : chr [1:414] \"Total\" \"tr1\" \"Total\" \"tr1\" ...\n  ..$ N_OBS          : int [1:414] 18 18 387 381 6 1 1 4 4 84 ...\n  ..$ TOT            : num [1:414] 853 853 43623 35503 8120 ...\n  ..$ MAX            : num [1:414] 303 303 6212 6212 4812 ...\n  ..$ is_secret_freq : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_dom  : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_prim : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_1    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_2    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_3    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_4    : logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ is_secret_final: logi [1:414] FALSE FALSE FALSE FALSE FALSE TRUE ...\n  ..$ statut_final   : chr [1:414] \"V\" \"V\" \"V\" \"V\" ...\n $ act_cj   :'data.frame':\t406 obs. of  14 variables:\n  ..$ ACTIVITY       : chr [1:406] \"01\" \"01\" \"01\" \"02\" ...\n  ..$ CJ             : chr [1:406] \"LL\" \"SP\" \"Total\" \"LL\" ...\n  ..$ N_OBS          : int [1:406] 9 9 18 240 147 387 1 1 1 3 ...\n  ..$ TOT            : num [1:406] 435 418 853 27625 15998 ...\n  ..$ MAX            : num [1:406] 263 303 303 6212 672 ...\n  ..$ is_secret_freq : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:406] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:406] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_size:'data.frame':\t460 obs. of  14 variables:\n  ..$ NUTS           : chr [1:460] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ SIZE           : chr [1:460] \"Total\" \"tr1\" \"tr2\" \"tr3\" ...\n  ..$ N_OBS          : int [1:460] 38462 37329 1096 37 19469 18919 529 21 2725 2649 ...\n  ..$ TOT            : num [1:460] 33026385 13774596 7172793 12078996 19217180 ...\n  ..$ MAX            : num [1:460] 3084242 1013320 513792 3084242 3084242 ...\n  ..$ is_secret_freq : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:460] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:460] \"V\" \"V\" \"V\" \"V\" ...\n $ nuts_cj  :'data.frame':\t452 obs. of  14 variables:\n  ..$ NUTS           : chr [1:452] \"FR10\" \"FR10\" \"FR10\" \"FR10\" ...\n  ..$ CJ             : chr [1:452] \"LL\" \"PA\" \"SP\" \"Total\" ...\n  ..$ N_OBS          : int [1:452] 28705 1012 8745 38462 15372 983 3114 19469 1598 1 ...\n  ..$ TOT            : num [1:452] 24151930 26238 8848217 33026385 13207770 ...\n  ..$ MAX            : num [1:452] 1674878 5577 3084242 3084242 1674878 ...\n  ..$ is_secret_freq : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_dom  : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_prim : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_1    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_2    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_3    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_4    : logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_secret_final: logi [1:452] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ statut_final   : chr [1:452] \"V\" \"V\" \"V\" \"V\" ...\n```\n:::\n:::\n\n\nOn peut ainsi dresser notre bilan par tableau :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasq_4tabs %>% \n  purrr::imap_dfr(\n    function(tab, nom){\n      tab %>% \n        count(statut_final) %>% \n        mutate(\n          part = n/sum(n)*100,\n          table = nom\n        ) %>% \n        relocate(table)\n    }\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       table statut_final   n      part\n1   act_size            A  52 12.560386\n2   act_size            D 108 26.086957\n3   act_size            V 254 61.352657\n4     act_cj            A  35  8.620690\n5     act_cj            D 113 27.832512\n6     act_cj            V 258 63.546798\n7  nuts_size            A  55 11.956522\n8  nuts_size            D  99 21.521739\n9  nuts_size            V 306 66.521739\n10   nuts_cj            A  45  9.955752\n11   nuts_cj            D 121 26.769912\n12   nuts_cj            V 286 63.274336\n```\n:::\n:::\n\n\n## Poser le secret en présence de hiérarchies non-emboîtées\n\nLorsque l'on a la présence de hiérarchie non-emboîtée dans les tableaux\ntraités alors il faut construire deux tableaux et deux hiérarchies pour\nchaque hiérarchie non-emboîtée.\n\nPar exemple, si on a un tableau T croisant NAF et GEO (deux variables\nhiérarchiques). Dans le cas où pour la NAF, en plus des activités\nclassiques, il est décidé de publier un agrégat supplémentaire AGREG =\nB12 + C15 + G45. Ainsi, AGREG ne peut pas s'insérer dans la NAF. Il faut\ndonc sortir cet agrégat pour construire un second tableau.\n\n-   T1, T2 croisent NAF et GEO\n-   T1 avec NAF classique (dont B12, C15, G45)\n-   T2 avec AGREG et ses composants B12, C15, G45\n\nRappel des arguments de `tab_multi_manager()` utiles pour traiter les\nhiérarchies non-emboîtées :\n\n-   **alt_totcode** : une liste nommée pour les codes de totaux\n    alternatifs (voir `alt_hrc` pour l'utilisation).\n\n-   **alt_hrc** : une liste nommée utile pour traiter les hiérarchies\n    non emboîtées. Les noms de la liste sont les noms des tableaux pour\n    lesquelles une autre hiérarchie (non emboîtée en général) doit être\n    utilisée (ex : si T1 et T2 ont une variable explicative, appelée\n    `ACTIVITY`, et la même variable de réponse, mais la variable\n    `ACTIVITY` n'a pas la même hiérarchie dans les les deux tables).\n    Supposons que les hiérarchies (`act1.hrc` et `act2.hrc`) ne sont pas\n    emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit\n    :\n\n    -   `hrc = c(ACTIVITY = \"path_to_file/act_1.hrc\")` : par défaut,\n        cette hiérarchie sera utilisée pour la variable ACTIVITY.\n\n    -   `alt_hrc = list(T2 = c(ACTIVITY = \"chemin_vers_fichier/act_2.hrc\"))`\n        dans la table T2, la hiérarchie alternative sera utilisée.\n\n## Utiliser les coûts\n\n*Objectif* : apprendre à utiliser l'option `cost` du package `rtauargus`\nafin de rediriger le secret secondaire.\n\nTau-Argus utilise des algorithmes d'optimisation afin de minimiser la\nperte d'information qui résulte du secret secondaire. La question qui se\npose est quelle valeur doit-être minimiser ? Plusieurs choix sont\npossibles, la valeur des cellules, le nombre de cellules, les effectifs\ndes cellules. Il est également possible de personnaliser les coûts si\nl'on souhaite prioriser la pose de secret secondaire sur certains\nagrégats.\n\n### Minimiser la valeur secrétisée\n\nTau-Argus minimise par défaut la valeur des cellules supprimées. C'est\nce qui est le plus cohérent, lorsque l'on publie un tableau c'est bien\nla valeur des cellules qui nous intéresse.\n\n### Minimiser le nombre de cellules secrétisées\n\nPour minimiser le nombre de cellules secrétisées il faut utiliser le\nparamètre `cost` et donc le définir dans notre table. si l'on souhaite\nminimiser le nombre de cellules masquées, il faut alors que le coût de\nsuppression de chaque cellule soit identique, Tau-Argus considère alors\nqu'elles ont toutes la même importance. Pour cela il faut créer une\ncolonne \"cost\" qui vaut 1 pour toutes les cellules de notre tableau.\n\n### Minimiser les effectifs secrétisés\n\nOn peut aussi considérer que la valeur importante des cellules sont\nleurs effectifs. On peut penser qu'un nombre de répondants élevé pour\nune cellule lui confère une plus grande fiabilité statistique. Pour cela\nil suffit simplement de recopier la colonne \"freq\" dans notre colonne\n\"cost\".\n\n### Orienter le secret secondaire\n\nDans certaines données on peut trouver des agrégats jugés non\nsignificatifs. Ces derniers ne seront pas publiés dans les tableaux mais\nnotés \"ns\". On peut alors s'en servir pour la pose du secret secondaire.\n\nAttention, on pourrait penser que ces cellules devraient être placées en\nsecret primaire, afin qu'elles soient considérées comme masquées quoi\nqu'il arrive. Cependant, cela peut entraîner plus de secret secondaire\nque nécessaire sachant qu'il n'est pas nécessaire de protéger ces\ncellules du risque de recoupement. L'utilisateur peut retrouver la\nvaleur de ces cellules, mais il est averti qu'elles n'ont aucune\nimportance statistique.\n\nPour prioriser le secret secondaire on crée donc pour les agrégats\nnon-significatifs la colonne \"cost\" qui vaut 1. C'est le coût minimal,\nceci indiquera à Tau-Argus que ces agrégats sont donc prioritaires pour\nle secret secondaire. Ainsi, certains coûts ne seront pas définis. Ce\nn'est pas un problème, lorsque l'on ne spécifie pas de coût pour une\ncellule, Tau-Argus va considérer que son coût de suppression est égal à\nla valeur de cette dernière.\n\n<!-- ## Différenciation avec diff man -->\n\n<!-- Niveau expert pour traiter non emboîtement epci x communes, mais on -->\n<!-- pourrait envisager hiérarchies non emboîtées si intégration de la -->\n<!-- gestion de la différenciation directement dans `rtauargus` -->\n",
    "supporting": [
      "04_fiches_pratiques_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
---
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE)
```

```{r import librairies, warning=FALSE, message=FALSE}
library(rtauargus)
library(dplyr)
```

# Fiches pratiques

Ces fiches pratiques ont été réalisées avec la version 1.2.0 de
`rtauargus` et la version 4.2.3 de `TauArgus`.

## Structure des données

Tous les tableaux fournis en entrée de `rtauargus` ont une structure
identique :

-   Les variables décrivant les croisements (variables catégorielles)
    sont placées au début
-   `FREQ` la variable indiquant le nombre d'unités statistiques
    contribuant à la cellule;
-   `VALUE` la variable indiquant la somme pondérée des valeurs de
    l'ensemble des contributeurs à la cellule (ex : un chiffre
    d'affaires, un nombre de personnes en emploi au 31/12, etc.);
-   `MAX` la valeur du plus gros contributeur à la cellule.

N.B : pour les tableaux de fréquence `FREQ` = `VALUE`.

## Préparation des tableaux pour la pose du secret

### **`tabulate_micro_data()`**

#### Présentation
Pour la pose du secret, outre la valeur des cellules (que l'on nommera
**`VALUE`**), il est nécessaire d'avoir des informations supplémentaires
par rapport au tableau publié :

-   **`FREQ`** : Le nombre d'unités statistiques ayant contribué à la
    cellule (pour déterminer le secret primaire de fréquence).
-   **`MAX`** : La valeur du plus gros contributeur de la cellule (pour
    déterminer le secret primaire de dominance)
-   les sous-totaux pour toutes les combinaisons possibles entre les
    variables. Par exemple, pour un tableau à 3 variables (A10 x SIZE x
    CJ)

|  A10  | SIZE  |  CJ   |
|:-----:|:-----:|:-----:|
| Total | Total | Total |
| Total | Total |  \*   |
| Total |  \*   | Total |
|  \*   | Total | Total |
| Total |  \*   |  \*   |
|  \*   | Total |  \*   |
|  \*   |  \*   | Total |

Il est possible de générer ce tableau soi-même. Mais pour faciliter la
préparation de ces informations, le package rtauargus contient la
fonction **`tabulate_micro_data`** pour le générer.

#### arguments

-   **`df`** : jeu de données individuelles (data.frame ou data.table)
-   **`cat_vars`** : Variables de croisements (catégorielles) non
    hiérarchiques (vecteur)
-   **`hrc_vars`** : Variables de croisements hiérarchiques sous la
    forme d'une liste nommée
-   **`pond_var`** : Variable de pondération
-   **`resp_var`** : Indicateur(s), variable(s) de réponse
-   **`marge_label`** : Label utilisé pour les marges (sous-totaux)

#### résultat

-   **`nb_obs`** : Comptage du nombre d'unités statistiques (**`FREQ`**)
-   **`X_tot`** : Indicateur / variable de réponse (**`VALUE`**)
-   **`X_max`** : Contribution maximale (**`MAX`**).

### EXEMPLES

#### Appel simple
Trois variables de croisement ("A10", "SIZE", "CJ") et une variable de réponse ("PRODUCTION").
```{r tabulerDonneesA}
data(indiv_dt)
dtDonneesMicro <- indiv_dt[, c("A10", "SIZE", "CJ", "PRODUCTION")]

DT::datatable(dtDonneesMicro)

dtDonneesTabulees <- tabulate_micro_data(dtDonneesMicro
                                         , cat_vars = c("A10", "SIZE", "CJ")
                                         , resp_var = "PRODUCTION"
                                         , marge_label = "Total")
DT::datatable(dtDonneesTabulees)
```

#### Variable de réponse pondérée
Dans le cas d'enquêtes non exhaustives, les observations sont pondérées. Pour indiquer la colonne de pondération, utiliser l'argument **`pond_var`**.
```{r tabulerDonneesB}
data(indiv_dt)
dtDonneesMicro <- indiv_dt[, c("A10", "SIZE", "CJ", "WEIGHT", "PRODUCTION")]

DT::datatable(dtDonneesMicro)

dtDonneesTabulees <- tabulate_micro_data(dtDonneesMicro
                                         , cat_vars = c("A10", "SIZE", "CJ")
                                         , resp_var = "PRODUCTION"
                                         , pond_var = "WEIGHT"
                                         , marge_label = "Total")
DT::datatable(dtDonneesTabulees)
```

#### Variable hiérarchique
Dans le cas de variables hiérarchiques (cf § 4.4), il faut utiliser l'argument **`hrc_vars`**.
```{r tabulerDonneesC}
data(indiv_dt)
dtDonneesMicro <- indiv_dt[, c("A10","A21","A88", "SIZE", "PRODUCTION")]

DT::datatable(dtDonneesMicro)

dtDonneesTabulees <- tabulate_micro_data(dtDonneesMicro
                                         , cat_vars = c("SIZE")
                                         , resp_var = "PRODUCTION"
                                         , hrc_vars = list(ACTIVITY = c("A10","A21","A88"))
                                         , marge_label = "Total")
DT::datatable(dtDonneesTabulees)
```

#### Deux indicateurs en même temps
Si plusieurs tableaux, portant sur des variables d'intéret différentes mais ont les mêmes variables de croisement, il est possible de préparer les tableaux de secret en un seul appel à **`tabulate_micro_data`**, en fournissant un vecteur à l'argument **`resp_var`**.
```{r tabulerDonneesD}
data(indiv_dt)
dtDonneesMicro <- indiv_dt[, c("SIZE", "CJ", "TURNOVER", "PRODUCTION")]

DT::datatable(dtDonneesMicro)

dtDonneesTabulees <- tabulate_micro_data(indiv_dt
                                         , cat_vars = c("SIZE", "CJ")
                                         , resp_var = c("TURNOVER", "PRODUCTION")
                                         , marge_label = "Total")
DT::datatable(dtDonneesTabulees)
```

#### Tableaux de fréquence

Les tableaux publiés sont souvent des tableaux de comptage. Par exemple,
combien *combien d'entreprises ont pour code NAF X*. Ces tableaux sont
un cas particulier. Leur **`VALUE`** est identique à leur **`FREQ`** et
leur **`MAX`** n'a pas de signification. Lors de l'appel à la fonction
**`tabulate_micro_data`**, on ne fournit pas de variable de réponse et
la fonction ne retourne que le comptage.

```{r tabulerDonneesE}
data(indiv_dt)
dtDonneesMicro <- indiv_dt[, c("A10", "SIZE", "CJ")]

DT::datatable(dtDonneesMicro)

dtDonneesTabulees <- tabulate_micro_data(dtDonneesMicro
                                         , cat_vars = c("A10", "SIZE", "CJ")
                                         , marge_label = "Total")
DT::datatable(dtDonneesTabulees)
```


## Prendre en compte une variable hiérarchique

Reprenons ici l'exemple de la variable `geo` qui est une variable
hiérarchique puisqu'il existe des emboîtements entre les différents
niveaux.

```{mermaid}
flowchart TD
  A[Pays] --> B[Nord]
  A --> C[Ouest]
  A --> D[Est]
  A --> E[Sud]
  B --> F[N1]
  B --> G[N2]
  B --> H[N3]
  C --> I[O1]
  C --> J[O2]
  C --> K[O3]
  C --> L[O4]
  D --> M[E1]
  D --> N[E2]
  D --> O[E3]
  E --> P[S1]
  E --> Q[S2]
```

Pour prendre en compte cette hiérarchie il faut d'abord pouvoir la
représenter de telle sorte que Tau-Argus comprenne les différents
emboîtements présents.

### Première option

La première option consiste à créer le fichier nécessaire (extension
`.hrc`) à la main. Ceci est tout à fait pertinent si la hiérarchie n'est
pas trop étendue.

Tau-Argus attend en effet un type de fichier bien particulier, dont
l'extension est `.hrc`. Il s'agit d'un simple fichier texte où les
différents emboîtements sont écrits les uns en-dessous des autres. Un
symbole (le `@`) est utilisé pour préciser le niveau de chacun des
emboîtements au sein de la hiérarchie.

Dans notre exemple on écrirait le fichier de la façon suivante :

```{tex}
Nord
@N1
@N2
@N3 
Ouest 
@O1 
@O2 
@O3 
@O4 
Est
@E1 
@E2 
@E3 
Sud 
@S1 
@S2
```

On remarque que le total `Pays` n'est pas inclus dans le fichier `.hrc`
c'est parce qu'il ne faut **pas indiquer le super-total de la
hiérarchie** à Tau-Argus.

### Seconde option

Quand la hiérarchie est très étendue, l'écriture manuelle du fichier de
hiérarchie est pénible. Or, quand ce genre de cas se présente, il existe
souvent une table de correspondance permettant d'associer les différents
niveaux entre eux.

Nous appelons table de correspondance une table qui précise l'ensemble
des niveaux associés aux emboîtements les plus fins.

La table de correspondance représentant la hiérarchie ci-dessus est la
suivante:

```{r}
pays_corr_table <- tibble(
  niv0 = "Pays",
  niv1 = c(rep("Nord",3),rep("Ouest",4),rep("Est",3), rep("Sud",2)),
  niv2 = c(paste0("N",1:3),paste0("O",1:4),paste0("E",1:3), paste0("S",1:2))
)
pays_corr_table
```

Avec la fonction `write_hrc2()` du package `rtauargus`, on peut
transformer la table de correspondance en un fichier `hrc`.

```{r}
write_hrc2(pays_corr_table %>% select(-niv0), file_name = "hrc/pays_TA_2.hrc")
```

Remarque: La fonction `rtauargus::write_hrc2()` n'accepte pas de valeurs
manquantes dans la table en entrée. Lorsqu'une hiérarchie n'a pas la
même nombre de sous-niveaux selon les branches on répète la modalité du
niveau supérieur sur les niveaux inférieurs pour ne pas avoir de cases
vides.

Exemple : pour la hiérarchie ci-dessous on répète la modalité `C` dans
la table de correspondance.

```{mermaid}
flowchart TD
  A[Total] --> B[A]
  A --> C[B]
  A --> D[C]
  B --> E[A1]
  B --> F[A2]
  C --> G[B1]
  C --> H[B2]
  H --> I[B21]
  H --> J[B22]
```

```{r}
corr_tab <- tibble(
  niv0 = "ALL",
  niv1 = c(rep("A",2),rep("B",3), "C"),
  niv2 = c("A1","A2","B1",rep("B2",2), "C"),
  niv3 = c("A1","A2","B1", "B21", "B22", "C")
)
corr_tab
```

## Poser le secret en présence de hiérarchies non-emboîtées

Lorsque l'on a la présence de hiérarchie non-emboîtée dans les tableaux
traités alors il faut construire deux tableaux et deux hiérarchies pour
chaque hiérarchie non-emboîtée.

Par exemple, le tableau `turnover_act_size` croise la NAF et les tranches d'effectifs
des entreprises. Si l'on décide de publier, en plus des activités
classiques de la NAF, un agrégat supplémentaire $AGREG = AZ + B$, 
alors il faut construire un tableau supplémentaire avec cet agrégat. En effet,
AGREG ne peut pas s'insérer dans la hiérarchie NAF, il faut donc construire deux hiérarchies :

-   la hiérarchie NAF (principale)
-   la hiérarchie de l'agrégat supplémentaire (alternative)

On crée le fichier `.hrc` de la hiérarchie principale à partir de la table de correspondance incluse dans le package.

```{r}
str(activity_corr_table)
```

```{r}
write_hrc2(activity_corr_table, file_name = "hrc/NAF_principale.hrc")
```

Puis on crée la hiérarchie alternative pour l'agrégat spécifique
```{r}
alt_corr_table <- tibble::tibble(
  niv0 = "AGREG",
  niv1 = c("B","AZ")
)

write_hrc2(alt_corr_table %>% select(-niv0), file_name = "hrc/AGREG_alt.hrc")
```

On construit les tableaux nécessaires à la pose du secret et on leur applique le secret primaire.
A savoir le tableau sur lequel la hiérarchie principale sera appliquée.
```{r}
turnover_act_size_detect <-  turnover_act_size %>%
  rename(FREQ = N_OBS, VALUE = TOT) %>% 
  mutate(
    is_secret_freq = FREQ > 0 & FREQ < 3,
    is_secret_dom = (VALUE != 0) & (MAX > 0.85*VALUE)
  ) %>% 
  mutate(
    is_secret_prim = is_secret_freq | is_secret_dom
  )
```


Et le tableau sur lequel la hiérarchie alternative sera appliquée, i.e. tableau uniquement avec
les modalités présentes dans la hiérarchie alternative et on pose le secret primaire.
```{r}
trunover_act_size_alt <- turnover_act_size_detect %>% 
  filter(ACTIVITY %in% c("AZ","B"))
```


::: {.callout-note}
## Arguments `tab_multi_manager()` pour traiter les hiérarchies non-emboîtées

-   **alt_totcode** : une liste nommée pour les codes de totaux
    alternatifs (voir `alt_hrc` pour l'utilisation).
-   **alt_hrc** : une liste nommée utile pour traiter les hiérarchies
    non emboîtées. Les noms de la liste sont les noms des tableaux pour
    lesquelles une autre hiérarchie (non emboîtée en général) doit être
    utilisée (ex : si T1 et T2 ont une variable explicative, appelée
    `ACTIVITY`, et la même variable de réponse, mais la variable
    `ACTIVITY` n'a pas la même hiérarchie dans les les deux tables).
    Supposons que les hiérarchies (`act1.hrc` et `act2.hrc`) ne sont pas
    emboîtées. Dans ce cas, nous écrivons les deux arguments comme suit
    :

    -   `hrc = c(ACTIVITY = "chemin_vers_fichier/act_1.hrc")` : par défaut,
        cette hiérarchie sera utilisée pour la variable ACTIVITY.
    -   `alt_hrc = list(T2 = c(ACTIVITY = "chemin_vers_fichier/act_2.hrc"))`
        dans la table T2, la hiérarchie alternative sera utilisée.
:::


```{r eval = FALSE}
masq_nonemb <- tab_multi_manager(
  list_tables = list(
    tab = turnover_act_size_detect,
    tab_alt = trunover_act_size_alt
    ),
  list_explanatory_vars = list(
    tab = c("ACTIVITY","SIZE"),
    tab_alt = c("ACTIVITY","SIZE")
    ),
  dir_name = "tauargus_files/hrc_nonemb",
  hrc = list(ACTIVITY = "hrc/NAF_principale.hrc"),
  alt_hrc = list(
    tab_alt = c(ACTIVITY = "hrc/AGREG_alt.hrc")
    ),
  totcode = "Total",
  alt_totcode = list(
    tab_alt = c(ACTIVITY = "AGREG")
    ),
  value = "VALUE",
  freq = "FREQ",
  secret_var = "is_secret_prim"
)
```


```{r import masque hrc_nonemb, echo = FALSE}
masq_nonemb <- readRDS("tauargus_files/hrc_nonemb/masq_nonemb.rds")
```


```{r}
masq_nonemb <- masq_nonemb %>% 
  purrr::map(
    function(tab){
      tab %>% 
        rename_with(~"is_secret_final", last_col()) %>% 
        mutate(
          statut_final = case_when(
            is_secret_freq ~ "A",
            is_secret_dom ~ "B",
            is_secret_final ~ "D",
            TRUE ~ "V"
          )
        )
    }
  )
str(masq_nonemb)
```

On peut dresser le bilan :
```{r}
masq_nonemb %>% 
  purrr::imap_dfr(
    function(tab, nom){
      tab %>% 
        count(statut_final) %>% 
        mutate(
          part = n/sum(n)*100,
          table = nom
        ) %>% 
        relocate(table)
    }
  )
```


## Utiliser les coûts

::: {.callout-important}
## Niveau expert
:::

*Objectif* : apprendre à utiliser l'option `cost` du package `rtauargus`
afin de rediriger le secret secondaire.

Tau-Argus utilise des algorithmes d'optimisation afin de minimiser la
perte d'information qui résulte du secret secondaire. La question qui se
pose est quelle valeur doit-être minimiser ? Plusieurs choix sont
possibles, la valeur des cellules, le nombre de cellules, les effectifs
des cellules. Il est également possible de personnaliser les coûts si
l'on souhaite prioriser la pose de secret secondaire sur certains
agrégats.

### Minimiser la valeur secrétisée

Tau-Argus minimise par défaut la valeur des cellules supprimées. C'est
ce qui est le plus cohérent, lorsque l'on publie un tableau c'est bien
la valeur des cellules qui nous intéresse.

### Minimiser le nombre de cellules secrétisées

Pour minimiser le nombre de cellules secrétisées il faut utiliser le
paramètre `cost` et donc le définir dans notre table. si l'on souhaite
minimiser le nombre de cellules masquées, il faut alors que le coût de
suppression de chaque cellule soit identique, Tau-Argus considère alors
qu'elles ont toutes la même importance. Pour cela il faut créer une
colonne "cost" qui vaut 1 pour toutes les cellules de notre tableau.

### Minimiser les effectifs secrétisés

On peut aussi considérer que la valeur importante des cellules sont
leurs effectifs. On peut penser qu'un nombre de répondants élevé pour
une cellule lui confère une plus grande fiabilité statistique. Pour cela
il suffit simplement de recopier la colonne "freq" dans notre colonne
"cost".

### Orienter le secret secondaire

Dans certaines données on peut trouver des agrégats jugés non
significatifs. Ces derniers ne seront pas publiés dans les tableaux mais
notés "ns". On peut alors s'en servir pour la pose du secret secondaire.

Attention, on pourrait penser que ces cellules devraient être placées en
secret primaire, afin qu'elles soient considérées comme masquées quoi
qu'il arrive. Cependant, cela peut entraîner plus de secret secondaire
que nécessaire sachant qu'il n'est pas nécessaire de protéger ces
cellules du risque de recoupement. L'utilisateur peut retrouver la
valeur de ces cellules, mais il est averti qu'elles n'ont aucune
importance statistique.

Pour prioriser le secret secondaire on crée donc pour les agrégats
non-significatifs la colonne "cost" qui vaut 1. C'est le coût minimal,
ceci indiquera à Tau-Argus que ces agrégats sont donc prioritaires pour
le secret secondaire. Ainsi, certains coûts ne seront pas définis. Ce
n'est pas un problème, lorsque l'on ne spécifie pas de coût pour une
cellule, Tau-Argus va considérer que son coût de suppression est égal à
la valeur de cette dernière.

**Exemple**

Si par exemple, on souhaite prioriser le secret sur la tranche d'effectif 1 `tr1`
dans `turnover_act_size`, tableau intégré à `rtauargus`.

Tout d'abord, on pose le secret primaire sur le tableau.
```{r}
data("turnover_act_size")

turnover_act_size_detect <-  turnover_act_size %>%
  rename(FREQ = N_OBS, VALUE = TOT) %>% 
  mutate(
    is_secret_freq = FREQ > 0 & FREQ < 3,
    is_secret_dom = (VALUE != 0) & (MAX > 0.85*VALUE)
  ) %>% 
  mutate(
    is_secret_prim = is_secret_freq | is_secret_dom
  )
```

Puis, on assigne on assigne la valeur 1 pour le coût de tous les croisements avec
`tr1`.
```{r}
turnover_act_size_ns <- turnover_act_size_detect %>%
  mutate(cost = ifelse(SIZE == "tr1", 1, VALUE))
str(turnover_act_size_ns)
```

On vérifie que les coûts à 1 ont bien été appliqués.
```{r}
str(turnover_act_size_ns %>% filter(cost == 1))
```


On pose le secret secondaire à l'aide de la fonction `tab_rtauargus()`.
```{r eval = FALSE}
res_ns <- tab_rtauargus(
  turnover_act_size_ns,
  files_name = "couts",
  dir_name = "tauargus_files/couts",
  explanatory_vars = c("ACTIVITY","SIZE"),
  totcode = c("Total","Total"),
  freq = "FREQ",
  value = "VALUE",
  secret_var = "is_secret_prim",
  cost_var = "cost",
  verbose = FALSE
)
```

```{r import masque couts, echo = FALSE}
res_ns <- readRDS("tauargus_files/couts/res_ns.rds")
```


On peut ensuite créer une synthèse du secret posé.
```{r}
synthese_ns <- res_ns %>% group_by(Status) %>%
  mutate(
    statut_final = case_when(
      is_secret_freq ~ "A",
      is_secret_dom ~ "B",
      TRUE ~ Status,
    )
  ) %>% 
  group_by(statut_final) %>% 
  summarise(
    nb_cellules = n(),
    effectif = sum(FREQ),
    valeur = sum(VALUE)
  )

synthese_ns
```


:::{.solutionbox}

::::{.solutionbox-header}
::::{.solutionbox-icon}
::::
This is my test code
::::

::::{.solutionbox-body}
And some content inside of it
::::

:::



